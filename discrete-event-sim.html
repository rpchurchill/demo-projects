<!doctype html>
<html>
<head>
  <title>Animation Demo</title>

  <meta charset="utf-8" />
  <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <script src="js/three.js"></script>
  <script src="js/StereoEffect.js"></script>

  <style>
    body {
      background-color: rgba(255,255,255,0);
      margin: 0;
      /*overflow: hidden;*/
    }
    .button_row {
      display: block;
      margin-top: -2px;
      width: 424px;
    }
    button {
      margin: 0;
      display: inline;
    }
    #window3D {
      display: block;
      border: 2px solid lime;
      margin-top: 2px;
      width: 420px;
      height: 260px;
    }
    #simClock {
      display: block;
      width: 300px;
      height: 20px;
      background-color: rgba(255,255,255,0);
      color: #FF0088;
      padding-left: 10px;
    }
    #simProgress {
      display: block;
      width: 418px;
      height: 198px;
      font-size: 0.8em;
    }
  </style> 
</head>

<body id="body" onload="initGraphics()">
  <div id="wrapper">
    <canvas id="bcanimation" height="465px" width="420px">The HTML5 Canvas object is not supported on your browser.</canvas>
    <div class="button_row">
      <button id="run_button" onmouseup="runClick()" style="height: 50px; width: 50px" disabled>Run</button>
      <button id="pause_button" onmouseup="pauseClick()" style="height: 50px; width: 50px" disabled>Pause</button>
      <button id="step_button" onmouseup="stepClick()" style="height: 50px; width: 154px" disabled>Step</button>
      <button id="reset_button" onmouseup="resetClick()" style="height: 50px; width: 50px" disabled>Reset</button>
      <button id="timeOps_button" onmouseup="toggleTimeOpsClick()" style="height: 50px; width: 50px" disabled>Time</button>
      <button id="multiplier_button" onmouseup="toggleMultiplier()" style="height: 50px; width: 50px; margin-right: 0;" disabled>x1</button>
    </div>
    <div id="window3D"></div>
    <div id="simClock"></div>
    <textarea id="simProgress"></textarea>
  </div>
  
  <script>
  "use strict";
/*  if (!Array.prototype.forEach)
   {
      console.log("array prototype needed to be defined");
      Array.prototype.forEach = function(fun /*, thisp*/ /*)
      {
         var len = this.length;
         
         if (typeof fun != "function")
         throw new TypeError();
         
         var thisp = arguments[1];
         for (var i = 0; i < len; i++)
         {
            if (i in this)
            fun.call(thisp, this[i], i, this);
         }
      };
   }  
*/
//***************************************************************************************
//*** random test stuff
//***************************************************************************************    
/*
    var randomFred = 3;
    
    function randomObject() {
      this.fred;
      this.setFred = function(fred) {
        this.fred = fred;
      }
      this.getFred = function() {
        return this.fred;
      }
    }
    
    jjj = new randomObject;
    jjj.setFred(randomFred);
    //expect 3
    alert("jjj.getFred: "+jjj.getFred());

    randomFred = 6;
    jjj.setFred(randomFred);
    //expect 6
    alert("jjj.getFred: "+jjj.getFred());
    
    randomFred = 9;
    //jjj.setFred(randomFred);
    //expect 9, get 6
    alert("jjj.getFred: "+jjj.getFred());

    function superObject() {
      this.superFred = 4;
      this.superFred1 = 7;
      this.superRandomObject = new randomObject();
      this.superRandomObject.setFred(this.superFred1);
      this.randomArray = [];
      this.randomArray[0] = new randomObject();
      this.randomArray[0].setFred(randomFred);
    }
    
    var super1 = new superObject;
    //expect 7
    alert("super1.superRandomObject.getFred: "+super1.superRandomObject.getFred());

    super1.superRandomObject.setFred(randomFred);
    //expect 6
    alert("super1.superRandomObject.getFred: "+super1.superRandomObject.getFred());

    super1.superRandomObject.setFred(super1.superFred);
    //expect 4
    alert("super1.superRandomObject.getFred: "+super1.superRandomObject.getFred());
    
    super1.superFred = 13;
    //expect 13, get 4
    alert("super1.superRandomObject.getFred: "+super1.superRandomObject.getFred());
    
    randomFred = 12;
    //expect 12, get 6
    alert("super1.randomArray[0].getFred(): "+super1.randomArray[0].getFred());
*/

//***************************************************************************************
//*** dummy variables for debugging
//***************************************************************************************
    var dummy1;
    var dummy2;
//***************************************************************************************
//*** utility and statistical functions for Discrete-Event Simulation Framework
//***************************************************************************************    
    function factorial(inputValue) {
      var input = Math.floor(inputValue);
      if (input < 0) {
        return -1;  //error condition
      } else if (input <= 1) {
        return 1;
      } else {
        var result = 1;
        for (var i=2; i<=input; i++) {
          result *= i;
        }
      }
      return result;
    }  //factorial
        
    function poissonSingle(arrivalsPerInterval,interval,occurrences) {
      //sanity check the input
      if (arrivalsPerInterval <= 0.0) {arrivalsPerInterval = 1.0;}
      if (interval <= 0.0) {interval = 1.0;}
      if (occurrences <= 0) {occurrences = 0;}
      
/*      //the clear way
      var lambda = arrivalsPerInterval / interval;
      var k = occurrences;
      var lambda_K = Math.pow(lambda,k);
      var e_minusLambda = Math.exp(-lambda);
      var kFact = factorial(k);
      var result = lambda_K * e_minusLambda / kFact;
      return result;  */
      
      //the faster way
      var lambda = arrivalsPerInterval / interval;
      return ((Math.pow(lambda,occurrences)) * (Math.exp(-lambda)) / factorial(occurrences));
    }  //poissonSingle

    function poissonCumulative(arrivalsPerInterval,interval) {
      //both numbers should be positive, do not need to be integers
      if (arrivalsPerInterval <= 0.0) {arrivalsPerInterval = 1.0;}
      if (interval <= 0.0) {interval = 1.0;}
      var cumulative = 0.0;
      var count = 0;
      var cumulations = [];
      while (cumulative < 0.9999999999) {
        //var next = poissonSingle(arrivalsPerInterval,interval,count);
        //cumulative += next;
        cumulative += poissonSingle(arrivalsPerInterval,interval,count);
        cumulations[count] = cumulative;
        count++;
      }
      cumulations[count] = 1.0;
      return cumulations;
    }  //poissonCumulative
    
    function poissonArrivals(randomValue,cumulation) {
      //expect 0.0 <= randomValue < 1.0, hack to condition input
      var input = randomValue;
      if (input < 0.0) {
        input = 0.0;
      } else if (input >= 1.0) {
        input = 0.9999999999;
      }
      var index = 0;
      while (cumulation[index] < input) {
        index++;
      }
      return index;
    }
    
/*    var c = poissonCumulative(3,1);
    var r = 0.999999999999999;
    var a = poissonArrivals(r,c);
    alert(a);  //result is 20
    r = 0.5;
    a = poissonArrivals(r,c);
    alert(a);  //result is 3
    r = Math.random();
    a = poissonArrivals(r,c);
    alert(a);  //result is ?
*/    
    
//    alert(poissonCumulative(6,1));
/*    alert(poissonSingle(6,1,0));
    alert(poissonSingle(6,1,1));
    alert(poissonSingle(6,1,2));
    alert(poissonSingle(6,1,3));
    alert(poissonSingle(6,1,4));
    alert(poissonSingle(6,1,5));
    alert(poissonSingle(6,1,6));
    alert(poissonSingle(6,1,7));
    alert(poissonSingle(6,1,8));
    alert(poissonSingle(6,1,9));
*/
//***************************************************************************************
//*** 2D graphics setup
//***************************************************************************************
    //var displayStartTime = 0.0;
    //var displayCurrentTime = 0.0;
    //var displayEndTime = 0.0;
    //var displayEntitiesScheduled = 0;
    //var displayEntityID = 0;
    //var initBallFlag = false;
    //var displayActivity = "";
    var globalWidth;
    var globalHeight;
    var globalBaseX = 0;
    var globalBaseY = 0;
    
    var canvas = document.getElementById("bcanimation");
    if (canvas) {
      //element already exists
      if (canvas.nodeName == "CANVAS") {
        globalWidth = canvas.width;
        globalHeight = canvas.height;
      } else {
        //element is *not* a canvas
        alert("Error: Element you've linked to is *not* a canvas.");
      }
    } else {
      //element does not already exist and must be created
      canvas = document.createElement("canvas");
      canvas.id = "bcanimation";
      canvas.height = 250;
      canvas.width = 420;
      globalWidth = canvas.width;
      globalHeight = canvas.height;
      document.body.appendChild(canvas);
    }
    canvas.style.border = "2px solid lime";
    var globalCTX = canvas.getContext("2d");
    
    
//***************************************************************************************
//*** basic 3D setup
//***************************************************************************************
    var fullScreen3D = false;
    var stereoVR = false;
    var renderer;
    var effect;
    var scene;
    var camera;
    var light;
    var fovBaseX;
    var fovBase = 75;
    
    function calcFovBaseX(angle,y) {
      var ang = angle / 180.0 * Math.PI;
      ang *= 0.5;
      var x = (y * 0.5) / Math.tan(ang);
      return x;
    }
    
    function calcFovAngle(height) {
      var hgt = height * 0.5;
      hgt /= fovBaseX;
      var angle = 2.0 * Math.atan(hgt);
      var ang = angle / Math.PI * 180.0;
      return ang;
    }
    
    fovBaseX = calcFovBaseX(75,500);  //returns 325.8063432103014
    var k = calcFovAngle(500);        //returns 75!
    
    function initGraphics3D() {
      renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
      if (fullScreen3D) {
        var handleBody = document.getElementById("body");
        handleBody.style.margin = "0px";
        handleBody.style.overflow = "hidden";
        //set wrapper div to not display
        var handleWrapper = document.getElementById("wrapper");
        handleWrapper.style.display = "none";
        //set the renderer to cover the entire screen
        renderer.setSize( window.innerWidth, window.innerHeight );
        fovBaseX = calcFovBaseX(fovBase, window.innerHeight);
        document.body.appendChild( renderer.domElement );
        if (stereoVR) {
          effect = new THREE.StereoEffect(renderer);
        }
      } else {
        renderer.setSize( 420,260 );
        fovBaseX = calcFovBaseX(fovBase, 260);
        var window3D = document.getElementById("window3D");
        window3D.appendChild( renderer.domElement );
      }
      renderer.setClearColor("#000000",1);

      scene = new THREE.Scene();
      if (fullScreen3D) {
        camera = new THREE.PerspectiveCamera( fovBase, window.innerWidth / window.innerHeight, 0.1, 1000 );
      } else {
        camera = new THREE.PerspectiveCamera( fovBase, 420 / 260, 0.1, 1000 );
      }
      light = new THREE.HemisphereLight( 0xeeeeee, 0x888888, 1 );
      light.position.set( 0, 300, 0 );
      scene.add( light );
    }  //initGraphics3D

//***************************************************************************************
//*** handle resize events when doing fullScreen3D
//***************************************************************************************
//from: http://stackoverflow.com/questions/641857/javascript-window-resize-event
/*
    function: addEvent

    @param: obj         (Object)(Required)
      - The object which you wish to attach your event to.

    @param: type        (String)(Required)
      - The type of event you wish to establish.

    @param: callback    (Function)(Required)
      - The method you wish to be called by your event listener.

    @param: eventReturn (Boolean)(Optional)
      - Whether you want the event object returned to your callback method.
*/
    var addEvent = function(obj, type, callback, eventReturn) {
      if(obj == null || typeof obj === 'undefined')
        return;

      if(obj.addEventListener)
        obj.addEventListener(type, callback, eventReturn ? true : false);
      else if(obj.attachEvent)
        obj.attachEvent("on" + type, callback);
      else
        obj["on" + type] = callback;
    };

    //An example call to the new addEvent function:

    var watch = function(evt) {
      //Older browser versions may return evt.srcElement
      //Newer browser versions should return evt.currentTarget
      var dimensions = {
        height: (evt.srcElement || evt.currentTarget).innerHeight,
        width: (evt.srcElement || evt.currentTarget).innerWidth
      };
      //https://threejs.org/docs/api/cameras/PerspectiveCamera.html
      renderer.setSize(dimensions.width, dimensions.height);
      camera.aspect = dimensions.width / dimensions.height;
      var newFov = calcFovAngle(dimensions.height);
      camera.fov = newFov;
      camera.updateProjectionMatrix();
    };

    if (fullScreen3D) {
      addEvent(window, 'resize', watch, true);
    }
//***************************************************************************************
//*** basic colors setup
//***************************************************************************************
    var globalNodeColor = "#FF00FF";
    var globalNodeVertexColor = "#FF22FF";
    var globalLabelColor = "#00FFFF";
    var globalValueColor = "#FF0000";
    var globalNeutralColor = "#FFFF00";
    var globalNeutralVertexColor = "#FFFF22";
    var globalReadyColor = "#00FF00";
    var globalReadyVertexColor = "22FF22";
    var globalWaitingColor = "#FF0000";
    var globalWaitingVertexColor = "#FF2222";
//***************************************************************************************
//*** data display variables
//***************************************************************************************
    function clearCanvas(color) {
      globalCTX.clearRect(0,0,globalWidth,globalHeight);
      globalCTX.fillStyle = color;
      globalCTX.fillRect(0,0,globalWidth,globalHeight);
    }  //clearCanvas
    clearCanvas("#000000");

    //function clearCanvas3D(color) {
    //  globalCTX3D.clearRect(0,0,420,260);
    //  globalCTX3D.fillStyle = color;
    //  globalCTX3D.fillRect(0,0,420,260);
    //}  //clearCanvas
    //clearCanvas3D("#0000FF");

    function DisplayValue(value,label,format,places) {
      //assumes alignment and color/fillStyle are set before calling
      this.value = value;
      this.label = label + ":";
      this.format = format;
      this.places = places;
      globalCTX.font = "12px Arial";
      this.width = globalCTX.measureText(label).width;
      this.getWidth = function() {
        return this.width;
      };
      //this.drawLabel = function(x,y) {
      //  globalCTX.fillText(this.label,x,y);
      //}
      this.updateValue = function(newValue) {  //newValue can/should be a function
        var tempValue = '';
        if (typeof newValue === "function") {
          tempValue = newValue.call(tempValue);
        } else {
          tempValue = newValue;
        }
        if (tempValue != this.value) {
          this.value = tempValue;
          return true;
        } else {
          return false;
        }
      };
      this.drawValue = function(x,y) {
        var s;
        if (this.format == "integer") {
          s = this.value;
        } else if (this.format == "numdec") {
          if (typeof this.value === "number") {
            s = this.value.toFixed(this.places);
          } else {
            s = this.value;
          }
        } else if (this.format == "numwide") {
          if (typeof this.value === "number") {
            s = this.value.toPrecision(this.places);
          } else {
            s = this.value;
          }
//          s = this.value.toPrecision(this.places);
        } else if (this.format == "text") {
          s = this.value;
        } else if (this.format == "bool") {
          if (typeof this.value === "boolean") {
            if (this.value) {
              s = "TRUE";
            } else {
              s = "FALSE";
            }
          } else {
            s = this.value;
          }
        }
        globalCTX.fillText(s,x,y);
      }
    }  //displayValue
    function DisplayGroup(label,x,y,vw,lc,vc,bc,displayDelay) {
      this.label = label;
      this.xLocation = x;
      this.yLocation = y;
      this.valueWidth = vw;
      this.labelColor = lc;
      this.valueColor = vc;
      this.borderColor = bc;
      this.displayDelay = displayDelay;
      if (this.label.length > 0) {
        this.labelHeight = 12;
      } else {
        this.labelHeight = 0;
      }
      this.visible = true;
      this.endDisplayTime = 0.0;
      this.turnOn = function() {
        this.visible = true;
        this.endDisplayTime = globalSimClock + this.displayDelay;
        advance(this.displayDelay,this,"turnOff");
      };
      this.turnOff = function() {
        if (globalSimClock >= this.endDisplayTime) {
          this.visible = false;
        }  //else a more recent value is in play and waiting to time out
      };
      this.setVisibility = function(visible) {
        this.visible = visible;
      };
      this.setBorderColor = function(ibc) {
        this.borderColor = ibc;
      };
      this.maxLabelWidth = 0;
      this.valueCount = 0;
      this.valueList = []; //new Array();
      this.define = function(label1,label2,x,y,vw,bc,vc,lc) {  
        //used to define outside of an object
        this.label = label1+": "+label2;
        this.xLocation = x;
        this.yLocation = y;
        this.valueWidth = vw;
        this.labelColor = lc;
        this.valueColor = vc;
        this.borderColor = bc;
        if (this.label.length > 0) {
          this.labelHeight = 12;
        } else {
          this.labelHeight = 0;
        }
      };
      this.addValue = function(value,label,format,places) {
        var tempValue = '';
        if (typeof value === "function") {
          tempValue = value.call(tempValue);
        } else {
          tempValue = value;
        }
        var v = new DisplayValue(tempValue,label,format,places);
        this.valueList.push(v);
        this.valueCount++;
        globalCTX.font = "12px Arial";
        var w = v.getWidth();
        if (w > this.maxLabelWidth) {
          this.maxLabelWidth = w;
        }
      };
      this.drawBasic = function() {
        if (this.visible) {
          this.height = (this.valueCount * 12) + this.labelHeight + 3;
          this.width = this.maxLabelWidth + this.valueWidth + 8;
          globalCTX.strokeStyle = this.borderColor;
          globalCTX.beginPath();
          globalCTX.moveTo(this.xLocation+0.5,this.yLocation+0.5);
          globalCTX.lineTo(this.xLocation+this.width+0.5,this.yLocation+0.5);
          globalCTX.lineTo(this.xLocation+this.width+0.5,this.yLocation+this.height+0.5);
          globalCTX.lineTo(this.xLocation+0.5,this.yLocation+this.height+0.5);
          globalCTX.lineTo(this.xLocation+0.5,this.yLocation+0.5);
          globalCTX.stroke();
          globalCTX.font = "12px Arial";
          globalCTX.fillStyle = this.labelColor;
          if (this.label.length > 0) {
            globalCTX.textAlign = "center";
            globalCTX.fillText(this.label,this.xLocation+(this.width*0.5),this.yLocation+12);
          }
          globalCTX.textAlign = "right";
          for (var i=0; i<this.valueCount; i++) {
            var l = this.valueList[i].label;
            var x = this.xLocation+this.maxLabelWidth+5;
            var y = this.yLocation+(i*12)+this.labelHeight+12;
            //globalCTX.fillText(valueList[i].label,this.xLocation+this.maxLabelWidth+3,this.yLocation+(i*12)+12);
            globalCTX.fillText(l,x,y);
          }
          globalCTX.fillStyle = this.valueColor;
          globalCTX.textAlign = "left";
          for (i=0; i<this.valueCount; i++) {
            this.valueList[i].drawValue(this.xLocation+this.maxLabelWidth+8,this.yLocation+(i*12)+this.labelHeight+12);
          }
        }
      };
      this.activate = function(nextState) {
        if (nextState == "turnOn") {
          this.turnOn();
        } else if (nextState == "turnOff") {
          this.turnOff();
        } else {
          errorUndefinedAdvanceState(this.entityID,this.nextState);
        }      
      };  //this.activate
    }  //DisplayGroup

    function DisplayGroup1() {
//      this.label = label;
//      this.xLocation = x;
//      this.yLocation = y;
//      this.valueWidth = vw;
//      this.labelColor = lc;
//      this.valueColor = vc;
//      this.borderColor = bc;
//      if (this.label.length > 0) {
//        this.labelHeight = 12;
//      } else {
//        this.labelHeight = 0;
//      }
      this.visible = true;
      this.endDisplayTime = 0.0;
      this.displayDelay = 0.0;
      this.turnOn = function() {
        this.visible = true;
        this.endDisplayTime = globalSimClock + this.displayDelay;
        advance(this.displayDelay,this,"turnOff");
      };
      this.turnOff = function() {
        this.visible = false;
      };
      this.defineOnOff = function(startVisibility,delayTime) {
        this.visible = startVisibility;
        this.displayDelay = delayTime;
      };
      this.setBorderColor = function(ibc) {
        this.borderColor = ibc;
      };
      this.maxLabelWidth = 0;
      this.labelHeight = 0;
      this.valueCount = 0;
      this.valueList = []; //new Array();
      this.define = function(label1,label2,x,y,vw,lc,vc,bc) {
        //used to define outside of an object
        this.label = label1+": "+label2;
        this.xLocation = x;
        this.yLocation = y;
        this.valueWidth = vw;
        this.labelColor = lc;
        this.valueColor = vc;
        this.borderColor = bc;
        if (this.label.length > 0) {
          this.labelHeight = 12;
        } else {
          this.labelHeight = 0;
        }
      };
      this.addValue = function(value,label,format,places) {
        var tempValue = '';
        if (typeof value === "function") {
          tempValue = value.call(tempValue);
        } else {
          tempValue = value;
        }
        var v = new DisplayValue(tempValue,label,format,places);
        this.valueList.push(v);
        this.valueCount++;
        globalCTX.font = "12px Arial";
        var w = v.getWidth();
        if (w > this.maxLabelWidth) {
          this.maxLabelWidth = w;
        }
      };
      this.drawBasic = function() {
        this.height = (this.valueCount * 12) + this.labelHeight + 3;
        this.width = this.maxLabelWidth + this.valueWidth + 8;
        globalCTX.strokeStyle = this.borderColor;
        globalCTX.beginPath();
        globalCTX.moveTo(this.xLocation+0.5,this.yLocation+0.5);
        globalCTX.lineTo(this.xLocation+this.width+0.5,this.yLocation+0.5);
        globalCTX.lineTo(this.xLocation+this.width+0.5,this.yLocation+this.height+0.5);
        globalCTX.lineTo(this.xLocation+0.5,this.yLocation+this.height+0.5);
        globalCTX.lineTo(this.xLocation+0.5,this.yLocation+0.5);
        globalCTX.stroke();
        globalCTX.font = "12px Arial";
        globalCTX.fillStyle = this.labelColor;
        if (this.label.length > 0) {
          globalCTX.textAlign = "center";
          globalCTX.fillText(this.label,this.xLocation+(this.width*0.5),this.yLocation+12);
        }
        globalCTX.textAlign = "right";
        for (var i=0; i<this.valueCount; i++) {
          var l = this.valueList[i].label;
          var x = this.xLocation+this.maxLabelWidth+5;
          var y = this.yLocation+(i*12)+this.labelHeight+12;
          //globalCTX.fillText(valueList[i].label,this.xLocation+this.maxLabelWidth+3,this.yLocation+(i*12)+12);
          globalCTX.fillText(l,x,y);
        }
        globalCTX.fillStyle = this.valueColor;
        globalCTX.textAlign = "left";
        for (i=0; i<this.valueCount; i++) {
          this.valueList[i].drawValue(this.xLocation+this.maxLabelWidth+8,this.yLocation+(i*12)+this.labelHeight+12);
        }
      };
    }  //DisplayGroup

    
/*    var fred = 4;
    var barney = Math.PI;
    var wilma = "Wilma";
    var betty = true;
    var pebbles = 247.94837747587382040906;
    var bambam = 747;
    
    var testGroup = new DisplayGroup("Test Group",20,20,100,"#00BBFF","#FF0000","#FFFF00",0.0);
    testGroup.addValue(fred,"Fred","integer");
    testGroup.addValue(barney,"Barney","numdec",4);
    testGroup.addValue(wilma,"Wilma","text");
    testGroup.addValue(betty,"Betty","bool");
    testGroup.addValue(pebbles,"Pebbles","numdec",8);
    testGroup.addValue(bambam,"Bam Bam","numwide",5);
    clearCanvas("#000000");
    testGroup.drawBasic();
    alert("hey hey hey");
    
    function getFred() {
      return fred;
    }
    
    fred = 5;
    barney = Math.PI * 2.0;
    function updateGroup1() {
      var anythingNew = false;
      if (testGroup.valueList[0].updateValue(getFred)) {
        anythingNew = true;
      }
      if (testGroup.valueList[1].updateValue(barney)) {
        anythingNew = true;
      }
      return anythingNew;
    }
    
    updateGroup1();
    clearCanvas("#000000");
    testGroup.drawBasic();
    alert("made my own subway");
*/

//***************************************************************************************
//*** 3D global variables
//***************************************************************************************
    var global3DComponentThickness = 6;
    var global3DTopHeight = global3DComponentThickness / 2;
    var global3DNodeUpOffset = 0.1;
    var global3DEntityHeight = 25;
    var global3DCameraRadiusFactor = 0.7;
    if (fullScreen3D) {
      if (stereoVR) {
        global3DCameraRadiusFactor = 1.0;
      } else {
        global3DCameraRadiusFactor = 0.8;
      }
    }
    var global3DCameraHeight = 100;
    var global3DMinX = Infinity;
    var global3DMinY = Infinity;
    var global3DMaxX = -Infinity;
    var global3DMaxY = -Infinity;

    function boundaryTest(x1,y1,x2,y2) {
      if (x1 < global3DMinX) {
        global3DMinX = x1;
      } else if (x1 > global3DMaxX) {
        global3DMaxX = x1;
      }
      if (y1 < global3DMinY) {
        global3DMinY = y1;
      } else if (y1 > global3DMaxY) {
        global3DMaxY = y1;
      }
      if (x2 < global3DMinX) {
        global3DMinX = x2;
      } else if (x2 > global3DMaxX) {
        global3DMaxX = x2;
      }
      if (y2 < global3DMinY) {
        global3DMinY = y2;
      } else if (y2 > global3DMaxY) {
        global3DMaxY = y2;
      }
    }
    
    var setOf3DEntities = [];

    var global3DRefreshEntityCount = 0;
    var global3DMaxEntityCount = 50;
    
    function define3DNode(x1,y1,nodeColor,nodeVertexColor) {
      var geometry = new THREE.CylinderGeometry( 3,3,global3DComponentThickness,10 );
      var material = new THREE.MeshPhongMaterial({
        color: nodeColor,
        shading: THREE.FlatShading,
        polygonOffset: true,
        polygonOffsetFactor: 1,  //positive value pushes polygon farther away
        polygonOffsetUnits: 1
      });
      var cylinder = new THREE.Mesh( geometry, material );

      // wireframe
      var geo = new THREE.EdgesGeometry( cylinder.geometry );
      var mat = new THREE.LineBasicMaterial( { color: nodeVertexColor, linewidth: 1 } );  //linewidth defaults to 1 in Windows iirc
      var wireFrame = new THREE.LineSegments( geo, mat );
      cylinder.add( wireFrame );

      cylinder.position.set(x1,global3DNodeUpOffset,y1);
      scene.add( cylinder );    
    }  //define3DNode
    
    function define3DPathComponent(x1,y1,x2,y2,pathColor) {
      boundaryTest(x1,y1,x2,y2);
      var material = new THREE.LineBasicMaterial({ color: pathColor });
      var geometry = new THREE.Geometry();
      geometry.vertices.push(
        new THREE.Vector3(x1,global3DTopHeight,y1),
        new THREE.Vector3(x2,global3DTopHeight,y2)
      );
      var line = new THREE.Line(geometry,material);
      scene.add(line);
      return line;
    }  //define3DPathComponent
    
    function define3DBoxComponent(x1,y1,w,h,faceColor,vertexColor,innode,outnode) {
      var x2 = x1 + w;
      var y2 = y1 + h;
      var geometry = new THREE.BoxGeometry( w, global3DComponentThickness, h );
      var material = new THREE.MeshPhongMaterial({
        color: faceColor,
        shading: THREE.FlatShading,
        polygonOffset: true,
        polygonOffsetFactor: 1,  //positive value pushes polygon farther away
        polygonOffsetUnits: 1
      });
      var box = new THREE.Mesh( geometry, material );
      
      // wireframe
      var geo = new THREE.EdgesGeometry( box.geometry );
      var mat = new THREE.LineBasicMaterial( { color: vertexColor, linewidth: 1 } );  //linewidth defaults to 1 in Windows iirc
      var wireFrame = new THREE.LineSegments( geo, mat );
      box.add( wireFrame );

      box.position.set(x1+(w/2),0,y1+(h/2));
      scene.add( box );
      
      //add the nodes as called for, don't need to create handles to them for now
      if (innode) {
        define3DNode(x1+(w/2),y1,globalNodeColor,globalNodeVertexColor);
      }
      if (outnode) {
        define3DNode(x1+(w/2),y2,globalNodeColor,globalNodeVertexColor);
      }
      
      boundaryTest(x1,y1,x2,y2);
      
      return box;
    }  //define3DBoxComponent
    
    function define3DEntity(x1,y1,bottomRadius,height,segments,faceColor,vertexColor) {
      var geometry = new THREE.CylinderGeometry(0,bottomRadius,height,segments);
      var material = new THREE.MeshPhongMaterial({
        color: faceColor,
        shading: THREE.FlatShading,
        polygonOffset: true,
        polygonOffsetFactor: 1,  //positive value pushes polygon farther away
        polygonOffsetUnits: 1
      });
      var cone = new THREE.Mesh( geometry, material );

      // wireframe
      var geo = new THREE.EdgesGeometry( cone.geometry );
      var mat = new THREE.LineBasicMaterial( { color: vertexColor, linewidth: 1 } );  //linewidth defaults to 1 in Windows iirc
      var wireframe = new THREE.LineSegments( geo, mat );
      cone.add( wireframe );

      cone.position.set(x1,(height+global3DComponentThickness),y1);
      scene.add( cone );
      setOf3DEntities.push(cone);
    }

    function colorToHex(color) {
      //strip off hash character
      var c = color.slice(1,color.length);
      //if 3 convert to 6
      if (c.length == 3) {
        c = c[0] + c[0] + c[1] + c[1] + c[2] + c[2];
      }
      return "0x" + c;
      //var r = (c[0]+c[1]) / 256;
      //var g = (c[2]+c[3]) / 256;
      //var b = (c[4]+c[5]) / 256;
      //return rgb(r,g,b);
    }
    
    var colorrgb = colorToHex("#f38");
    
    function update3DPathColor(component3D,lineColor) {
      component3D.material.color.setHex(colorToHex(lineColor));
    }

    function update3DEntity(index,x1,y1,faceColor,vertexColor) {
      setOf3DEntities[index].material.color.setHex(colorToHex(faceColor));
      setOf3DEntities[index].children[0].material.color.setHex(colorToHex(vertexColor));
      setOf3DEntities[index].position.x = x1;
      setOf3DEntities[index].position.y = global3DTopHeight + (global3DEntityHeight / 2) + global3DNodeUpOffset;
      setOf3DEntities[index].position.z = y1;
    }
    
    function normalize3DEntities(startIndex) {
      if (startIndex > global3DMaxEntityCount) {
        alert("asked to normalize at too many 3D entities");
      }
      for (var i=startIndex; i < global3DMaxEntityCount; i++) { 
        update3DEntity(i,10000,10000,globalReadyColor,globalReadyVertexColor);
      }
    }
  
    function update3DComponentColor(component3D,faceColor,vertexColor) {
      component3D.material.color.setHex(colorToHex(faceColor));
      component3D.children[0].material.color.setHex(colorToHex(vertexColor));
    }
    
    //define3DBoxComponent(61,2,146,98,"#FFFF00","#222222",false,false);
    //define3DBoxComponent(90,105,88,20,"#FFFF00","#222222",false,true);
    //define3DPathComponent(134,125,160,137,"#FFFF00");
    //define3DPathComponent(160,137,134,150,"#FFFF00");
    //define3DNode(160,137);
    //define3DBoxComponent(90,150,88,80,"#FFFF00","#222222",true,true);
    //define3DNode(134,116);




    //define3DNode(0,0);
    //define3DNode(150,0);
    //define3DNode(0,150);
    //define3DNode(-150,0);
    //define3DNode(0,-150);

//***************************************************************************************
//*** graphics display variables
//***************************************************************************************
    function DisplayElement(parent,x1,y1,w,h,angle,count,traverse,xylocs) {
      if (typeof x1 === "undefined") {x1 = 0;}
      if (typeof y1 === "undefined") {y1 = 0;}
      if (typeof w === "undefined") {w = 0;}
      if (typeof h === "undefined") {h = 0;}
      if (typeof angle === "undefined") {angle = 0.0;}
      if (typeof count === "undefined") {count = false;}
      if (typeof traverse === "undefined") {traverse = false;}
      if (typeof xylocs === "undefined") {xylocs = [[]];}
      //TODO: include mechanisms for drawing paths here
      this.parent = parent;
      this.x1 = x1;
      this.y1 = y1;
      if ((this.parent.getComponentType() == "startSubJourney") ||
          (this.parent.getComponentType() == "returnFromSubJourney")) {
        this.x2 = w;
        this.y2 = h;
        this.isJourney = true;
        this.isPath = false;
      } else if (this.parent.getComponentType() != "Path") {
        this.x2 = x1 + w;
        this.y2 = y1 + h;
        this.isJourney = false;
        this.isPath = false;
      } else {
        this.x2 = w;
        this.y2 = h;
        this.isJourney = false;
        this.isPath = true;
      }
      this.angle = angle;  //not used for now, default to 0.0;
      this.index = this.parent.getComponentID();
      this.nodeColor = globalNodeColor;
      var tempType = this.parent.getComponentType();
      switch (tempType) {
        case "Queue": this.type = "Q"; break;
        case "Process": this.type = "P"; break;
        case "Combined": this.type = "C"; break;
        case "Entry": this.type = "E"; break;
        case "Exit": this.type = "X"; break;
        case "Bag": this.type = "B"; break;
        case "Stack": this.type = "S"; break;
        case "Control": this.type = "D"; break;  //D for Decision
        default: this.type = "?";
      }
      this.label = this.index + "-" + this.type + ": " +this.parent.getComponentName();
      this.labelWidth = globalCTX.measureText(this.label).width;
      this.innode = true;
      this.outnode = true;
      if (this.parent.getComponentType() == "Entry") {
        this.innode = false;
      } else if (this.parent.getComponentType() == "Exit") {
        this.outnode = false;
      } else if (this.parent.getComponentType() == "Arrivals") {
        this.innode = false;
      } else if (this.parent.getComponentType() == "startSubJourney") {
        this.innode = false;
      } else if (this.parent.getComponentType() == "returnFromSubJourney") {
        this.outnode = false;
      }
      this.count = count;
      this.traverse = traverse;
      this.countValue = 0;
      this.traverseValue = 0;
      this.nodexi = w * 0.5;
      this.nodexo = this.nodexi;
      this.nodeyi = 0.0;
      this.nodeyo = h;
      this.locsCount = [];
      for (var i=0; i<xylocs.length; i++) {
        this.locsCount[i] = xylocs[i].length;
      }
      this.entityLocs = xylocs;
      this.component3D = null;
      //use this information to define a 3D display component
      
      for (var i=0; i<this.locsCount; i++) {
        this.entityLocs.push(xylocs[i]);
      }
      this.addXYLoc = function(index, xl,yl) {
        if (index == this.entityLocs.length) {  //new index must equal old count e.g., entityLocs[0] length is 1 entityLocs[1] length is 2 etc.
          this.entityLocs.push([]);
          this.locsCount[index] = 0;
        } else if (index > this.entityLocs.length) {
          alert("component "+this.parent.getComponentID+" adding too high of an index to locations array");
        }
        var loc = {x: xl, y: yl};
        this.entityLocs[index].push(loc);
        this.locsCount[index]++;
      };
      this.setNeutralColor = function(nc) {
        this.neutralColor = nc;
      };
      this.setTraverseValue = function(tv) {
        this.traverseValue = tv;
      };
      this.setCountValue = function(cv) {
        this.countValue = cv;
      };
      this.setStartPoint = function(x1,y1) {
        this.x1 = x1;
        this.y1 = y1;
      };
      this.setEndPoint = function(x2,y2) {
        this.x2 = x2;
        this.y2 = y2;
      };
      this.getInNode = function() {
        if (this.innode) {
          //if (this.parent.getComponentType() != "Path") {
          if (this.isJourney) {
            return {x: this.x1, y: this.y1};
          } else if (!this.isPath) {
            return {x: this.x1+this.nodexi, y: this.y1+this.nodeyi};
          } else {
            return {x: this.x1, y: this.y1};
          }
        } else {
          alert("display element queried for non-existent incoming node");
          return null;  //in theory this should never happen
        }
      };
      this.getOutNode = function() {
        if (this.outnode) {
          //if (this.parent.getComponentType() != "Path") {
          if (this.isJourney) {
            return {x: this.x2, y: this.y2};
          } else if (!this.isPath) {
            return {x: this.x1+this.nodexo, y: this.y1+this.nodeyo};
          } else {
            return {x: this.x2, y: this.y2};
          }
        } else {
          alert("display element queried for non-existent outgoing node");
          return null;  //in theory this should never happen
        }
      };
      this.defineColors = function(lc,vc,nc,nvc,rc,rvc,wc,wvc) {
        this.labelColor = lc;             //text labels
        this.valueColor = vc;             //text values
        this.neutralColor = nc;           //non-exclusive path and component color
        this.neutralVertexColor = nvc;    //non-exclusive wireframe color
        this.readyColor = rc;             //exclusive open component or ready-to-go entity color
        this.readyVertexColor = rvc;      //exclusive open component or ready-to-go entity vertex color
        this.waitingColor = wc;           //exclusive closed component or in-process entity color
        this.waitingVertexColor = wvc;    //exclusive closed component or in-process entity vertex color
      };
      this.defineGlobalDefaultColors = function() {
        this.defineColors(globalLabelColor,globalValueColor,globalNeutralColor,globalNeutralVertexColor,
                          globalReadyColor,globalReadyVertexColor,globalWaitingColor,globalWaitingVertexColor);
      };
      this.defineGlobalDefaultColors();
      this.drawBasic = function() {
        var borderColor;
        if (this.parent.getExclusive()) {
          if (this.parent.getOpenStatus()) {
            borderColor = this.readyColor;
          } else {
            borderColor = this.waitingColor;
          }
        } else {
          borderColor = this.neutralColor;
        }
        //if (this.parent.getComponentType() != "Path") {
        if (this.isJourney) {
          globalCTX.strokeStyle = borderColor;
          globalCTX.beginPath();
          if (this.innode) {
            globalCTX.moveTo(this.x1-5-globalBaseX+0.5,this.y1-5-globalBaseY+0.5);
            globalCTX.lineTo(this.x1+4-globalBaseX+0.5,this.y1-5-globalBaseY+0.5);
            globalCTX.lineTo(this.x1+4-globalBaseX+0.5,this.y1+4-globalBaseY+0.5);
            globalCTX.lineTo(this.x1-5-globalBaseX+0.5,this.y1+4-globalBaseY+0.5);
            globalCTX.lineTo(this.x1-5-globalBaseX+0.5,this.y1-5-globalBaseY+0.5);
          } else { //outnode
            globalCTX.moveTo(this.x2-5-globalBaseX+0.5,this.y2-5-globalBaseY+0.5);
            globalCTX.lineTo(this.x2+4-globalBaseX+0.5,this.y2-5-globalBaseY+0.5);
            globalCTX.lineTo(this.x2+4-globalBaseX+0.5,this.y2+4-globalBaseY+0.5);
            globalCTX.lineTo(this.x2-5-globalBaseX+0.5,this.y2+4-globalBaseY+0.5);
            globalCTX.lineTo(this.x2-5-globalBaseX+0.5,this.y2-5-globalBaseY+0.5);
          }
          globalCTX.stroke();
          //do nothing
        } else if (!this.isPath) {
          var runningHeight = 15;
          globalCTX.strokeStyle = borderColor;
          globalCTX.beginPath();
          globalCTX.moveTo(this.x1-globalBaseX+0.5,this.y1-globalBaseY+0.5);
          globalCTX.lineTo(this.x2-globalBaseX+0.5,this.y1-globalBaseY+0.5);
          globalCTX.lineTo(this.x2-globalBaseX+0.5,this.y2-globalBaseY+0.5);
          globalCTX.lineTo(this.x1-globalBaseX+0.5,this.y2-globalBaseY+0.5);
          globalCTX.lineTo(this.x1-globalBaseX+0.5,this.y1-globalBaseY+0.5);
          globalCTX.stroke();
          globalCTX.font = "12px Arial";
          globalCTX.fillStyle = this.labelColor;
          globalCTX.textAlign = "center";
          globalCTX.fillText(this.label,this.x1+this.nodexi-globalBaseX,this.y1+runningHeight-globalBaseY);
          runningHeight += 12;
          if (this.traverse) {
            globalCTX.textAlign = "right";
            var waitChar = "P:";
            if (this.parent.getComponentType() == "Queue") {
              waitChar = "T:";
            } else if (this.parent.getComponentType() == "Process") {
              waitChar = "P:";
            } 
            globalCTX.fillText(waitChar,x1-globalBaseX+15,this.y1-globalBaseY+runningHeight);
            globalCTX.fillStyle = this.valueColor;
            globalCTX.textAlign = "left";
            globalCTX.fillText(this.traverseValue,x1-globalBaseX+17,this.y1-globalBaseY+runningHeight);
            runningHeight += 12;
          }
          if (this.count) {
            globalCTX.fillStyle = this.labelColor;
            globalCTX.textAlign = "right";
            globalCTX.fillText("Q:",x1-globalBaseX+15,this.y1-globalBaseY+runningHeight);
            globalCTX.fillStyle = this.valueColor;
            globalCTX.textAlign = "left";
            globalCTX.fillText(this.countValue,x1-globalBaseX+17,this.y1-globalBaseY+runningHeight);
            runningHeight += 12;
          }
        } else {
          globalCTX.strokeStyle = borderColor;
          globalCTX.beginPath();
          globalCTX.moveTo(this.x1-globalBaseX+0.5,this.y1-globalBaseY+0.5);
          globalCTX.lineTo(this.x2-globalBaseX+0.5,this.y2-globalBaseY+0.5);
          globalCTX.stroke();        
        }
      };
      this.drawNodes = function() {
        //if (this.parent.getComponentType() != "Path") {
        if (this.isJourney) {
          if (this.innode) {
            drawNode(this.x1-globalBaseX,this.y1-globalBaseY,3,this.nodeColor);
          }
          if (this.outnode) {
            drawNode(this.x2-globalBaseX,this.y2-globalBaseY,3,this.nodeColor);
          }        
        } else if (!this.isPath) {
          if (this.innode) {
            drawNode(this.x1+this.nodexi-globalBaseX,this.y1+this.nodeyi-globalBaseY,3,this.nodeColor);
          }
          if (this.outnode) {
            drawNode(this.x1+this.nodexo-globalBaseX,this.y1+this.nodeyo-globalBaseY,3,this.nodeColor);
          }
        } else {
          if (this.parent.previousComponent.getComponentType() == "Path") {
            drawNode(this.x1-globalBaseX,this.y1-globalBaseY,3,this.nodeColor);
          }
          if (this.parent.nextComponent.getComponentType() == "Path") {
            drawNode(this.x2-globalBaseX,this.y2-globalBaseY,3,this.nodeColor);
          }
        }
      };
      this.drawEntities = function() {
        var i;
        var drawCount;
        var drawColor;
        var xx;
        var yy;
        var qCount;
        //if (this.parent.getComponentType() == "Path") {
        if (this.isPath) {
          drawCount = this.parent.entityQueue.length;
          for (i=0; i<drawCount; i++) {
            var location = this.parent.entityQueue[i].getLocation();
            drawNode(location.x-globalBaseX,location.y-globalBaseY,5,this.readyColor);
            drawNode(location.x-globalBaseX,location.y-globalBaseY,3,this.parent.entityQueue[i].getEntityColor())
          }
        } else if (this.parent.getComponentType() == "Bag") {
          drawCount = this.parent.maxCapacity;  //should be < this.entityLocs.length
          drawColor = this.waitingColor;
          for (i=0; i<drawCount; i++) {
            if (this.parent.entityQueue[i] != null) {
              xx = this.entityLocs[0][i].x-globalBaseX;
              yy = this.entityLocs[0][i].y-globalBaseY;
              drawNode(this.x1+xx,this.y1+yy,5,drawColor);
              drawNode(this.x1+xx,this.y1+yy,3,this.parent.entityQueue[i].getEntityColor());
              if (this.parent.subEntityQueue[i] != null) {
                drawNode(this.x1+xx+3,this.y1+yy-3,5,drawColor);
                drawNode(this.x1+xx+3,this.y1+yy-3,3,this.parent.subEntityQueue[i].getEntityColor());
              }
            }
          }
          drawCount = this.entityLocs[0].length - this.parent.maxCapacity;
          if (this.parent.exitQueue.length < drawCount) {
            drawCount = this.parent.exitQueue.length;
          }
          drawColor = this.readyColor;
          for (i=0; i<drawCount; i++) {
            //locs for exit queue in order from maxCapacity
            xx = this.entityLocs[0][this.parent.maxCapacity + i].x-globalBaseX;
            yy = this.entityLocs[0][this.parent.maxCapacity + i].y-globalBaseY;
            drawNode(this.x1+xx,this.y1+yy,5,drawColor);
            //exit queue items in reverse order
            drawNode(this.x1+xx,this.y1+yy,3,this.parent.exitQueue[this.parent.exitQueue.length-1-i].getEntityColor());            
          }
        } else if (this.parent.getComponentType()== "Combined") {
          //var locs = this.entityLocs.length;
          qCount = this.countValue - this.traverseValue;
          //drawCount = locs - this.parent.processCapacity;
          drawCount = this.locsCount[0] - this.parent.processCapacity;
          if (this.parent.entityQueue.length < drawCount) {
            drawCount = this.parent.entityQueue.length;
          }
          for (i=0; i<drawCount; i++) {
            if (i < qCount) {
              drawColor = this.readyColor;
            } else {
              drawColor = this.waitingColor;
            }
            xx = this.entityLocs[0][i].x-globalBaseX;
            yy = this.entityLocs[0][i].y-globalBaseY;
            drawNode(this.x1+xx,this.y1+yy,5,drawColor);
            drawNode(this.x1+xx,this.y1+yy,3,this.parent.entityQueue[i].getEntityColor());
          }
          var pCount = this.parent.countInProcessQueue - this.parent.countInProcess;
          drawCount = this.parent.countInProcessQueue;
          //start from end of entityLocs
          for (i=0; i<drawCount; i++) {
            if (i < pCount) {
              drawColor = this.readyColor;
            } else {
              drawColor = this.waitingColor;
            }
            //xx = this.entityLocs[0][locs-i-1].x;
            //yy = this.entityLocs[0][locs-i-1].y;
            xx = this.entityLocs[0][this.locsCount[0]-i-1].x-globalBaseX;
            yy = this.entityLocs[0][this.locsCount[0]-i-1].y-globalBaseY;
            drawNode(this.x1+xx,this.y1+yy,5,drawColor);
            drawNode(this.x1+xx,this.y1+yy,3,this.parent.processQueue[drawCount-i-1].getEntityColor());
          }
        } else if (this.parent.getComponentType() != "Arrivals") {
          if (this.parent.componentName == "Q0") {
            dummy1 = 6;
          }
          qCount = this.countValue - this.traverseValue;
          if (this.countValue > this.locsCount[0]) {
            drawCount = this.locsCount[0];
          } else {
            drawCount = this.countValue;
          }
          for (i=0; i<drawCount; i++) {
            if (i < qCount) {
              drawColor = this.readyColor;
            } else {
              drawColor = this.waitingColor;
            }
            xx = this.entityLocs[0][i].x-globalBaseX;
            yy = this.entityLocs[0][i].y-globalBaseY;
            drawNode(this.x1+xx,this.y1+yy,5,drawColor);
            drawNode(this.x1+xx,this.y1+yy,3,this.parent.entityQueue[i].getEntityColor());
          }
        }
      };
      this.define3DComponent = function() {
        //when everything else is defined and verified, call this to build 3D component info list
        var faceColor;
        var vertexColor;
        if (this.parent.getExclusive()) {
          if (this.parent.getOpenStatus()) {
            faceColor = this.readyColor;
            vertexColor = this.readyVertexColor;
          } else {
            faceColor = this.waitingColor;
            vertexColor = this.waitingVertexColor;          
          }
        } else {
          faceColor = this.neutralColor;
          vertexColor = this.neutralVertexColor;
        }
        if (this.isPath) {
          this.component3D = define3DPathComponent(this.x1,this.y1,this.x2,this.y2,faceColor);
          if (this.parent.nextComponent.getComponentType() == "Path") {
            //define a 3D node here, only at the end of the first path
            define3DNode(this.x2,this.y2,globalNodeColor,globalNodeVertexColor);
          }
        } else if (this.parent.getComponentType() != "Arrivals") {
          if (!this.isJourney) {
            this.component3D = define3DBoxComponent(this.x1,this.y1,w,h,faceColor,vertexColor,this.innode,this.outnode);
          } else {
            if (this.outnode) {
              define3DNode(this.x2,this.y2,globalNodeColor,globalNodeVertexColor);
            } 
            if (this.innode) {
              define3DNode(this.x1,this.y1,globalNodeColor,globalNodeVertexColor);
            } 
          }
        } else {
          //do nothing
        }
      };
      this.update3DComponent = function() {
        var faceColor;
        var vertexColor;
        if (this.parent.getExclusive()) {
          if (this.parent.getOpenStatus()) {
            faceColor = this.readyColor;
            vertexColor = this.readyVertexColor;
          } else {
            faceColor = this.waitingColor;
            vertexColor = this.waitingVertexColor;          
          }
        } else {
          faceColor = this.neutralColor;
          vertexColor = this.neutralVertexColor;
        } 
        if (this.isPath) {
          update3DPathColor(this.component3D,faceColor);
        } else if (this.parent.getComponentType() != "Arrivals") {
          if (!this.isJourney) {
            update3DComponentColor(this.component3D,faceColor,vertexColor);
          }
        }
      };
      this.update3DEntities = function() {
        var i;
        var drawCount;
        var qCount;
        var faceColor;
        var vertexColor;
        if (this.isPath) {
          drawCount = this.parent.entityQueue.length;
          for (i=0; i<drawCount; i++) {
            var location = this.parent.entityQueue[i].getLocation();
            update3DEntity(global3DRefreshEntityCount++,location.x,location.y,this.readyColor,this.readyVertexColor);
          }
        } else if (this.parent.getComponentType() == "Bag") {
          drawCount = this.parent.maxCapacity;  //should be < this.entityLocs[0].length
          faceColor = this.waitingColor;
          vertexColor = this.waitingVertexColor;
          for (i=0; i<drawCount; i++) {
            if (this.parent.entityQueue[i] != null) {
              xx = this.x1 + this.entityLocs[0][i].x;
              zz = this.y1 + this.entityLocs[0][i].y;
              update3DEntity(global3DRefreshEntityCount++,xx,zz,faceColor,vertexColor);
              if (this.parent.subEntityQueue[i] != null) {
                //drawNode(this.x1+xx+3,this.y1+yy-3,5,drawColor);
                //drawNode(this.x1+xx+3,this.y1+yy-3,3,this.parent.subEntityQueue[i].getEntityColor());
              }
            }
          }
          drawCount = this.entityLocs[0].length - this.parent.maxCapacity;
          if (this.parent.exitQueue.length < drawCount) {
            drawCount = this.parent.exitQueue.length;
          }
          faceColor = this.readyColor;
          vertexColor = this.readyVertexColor;
          for (i=0; i<drawCount; i++) {
            //locs for exit queue in order from maxCapacity
            xx = this.x1 + this.entityLocs[0][this.parent.maxCapacity + i].x;
            zz = this.y1 + this.entityLocs[0][this.parent.maxCapacity + i].y;
            update3DEntity(global3DRefreshEntityCount++,xx,zz,faceColor,vertexColor);
            //drawNode(this.x1+xx,this.y1+yy,5,drawColor);
            //exit queue items in reverse order
            //drawNode(this.x1+xx,this.y1+yy,3,this.parent.exitQueue[this.parent.exitQueue.length-1-i].getEntityColor());            
          }
        } else if (this.parent.getComponentType()== "Combined") {
          qCount = this.countValue - this.traverseValue;
          drawCount = this.locsCount[0] - this.parent.processCapacity;
          if (this.parent.entityQueue.length < drawCount) {
            drawCount = this.parent.entityQueue.length;
          }
          for (i=0; i<drawCount; i++) {
            if (i < qCount) {
              faceColor = this.readyColor;
              vertexColor = this.readyVertexColor;
            } else {
              faceColor = this.waitingColor;
              vertexColor = this.waitingVertexColor;
            }
            xx = this.x1 + this.entityLocs[0][i].x;
            zz = this.y1 + this.entityLocs[0][i].y;
            update3DEntity(global3DRefreshEntityCount++,xx,zz,faceColor,vertexColor);
          }
          var pCount = this.parent.countInProcessQueue - this.parent.countInProcess;
          drawCount = this.parent.countInProcessQueue;
          //start from end of entityLocs
          for (i=0; i<drawCount; i++) {
            if (i < pCount) {
              faceColor = this.readyColor;
              vertexColor = this.readyVertexColor;
            } else {
              faceColor = this.waitingColor;
              vertexColor = this.waitingVertexColor;
            }
            xx = this.x1 + this.entityLocs[0][this.locsCount[0]-i-1].x;
            zz = this.y1 + this.entityLocs[0][this.locsCount[0]-i-1].y;
            update3DEntity(global3DRefreshEntityCount++,xx,zz,faceColor,vertexColor);
          }
        } else if (this.parent.getComponentType() != "Arrivals") {
          qCount = this.countValue - this.traverseValue;
          if (this.countValue > this.locsCount[0]) {
            drawCount = this.locsCount[0];
          } else {
            drawCount = this.countValue;
          }
          for (i=0; i<drawCount; i++) {
            if (i < qCount) {
              faceColor = this.readyColor;
              vertexColor = this.readyVertexColor;
            } else {
              faceColor = this.waitingColor;
              vertexColor = this.waitingVertexColor;
            }
            var xx = this.x1 + this.entityLocs[0][i].x;
            //var yy = global3DTopHeight + (global3DEntityHeight / 2) + global3DNodeUpOffset;  //declared inside update3DEntity
            var zz = this.y1 + this.entityLocs[0][i].y;
            update3DEntity(global3DRefreshEntityCount++,xx,zz,faceColor,vertexColor);
          }
        }
      };
      this.parent.defineGraphic(this);
    }  //DisplayElement
//***************************************************************************************
//*** start Discrete-Event Simulation Framework
//***************************************************************************************
    //controls update of graphical and numeric displays
    var displayControlMode = "Time";  //"Ops"; //"Time";
    var displayControlUpdate = true;

    var timeOpsToggleButton = document.getElementById("timeOps_button");

    function toggleTimeOpsClick() {
      if (displayControlMode == "Time") {
        displayControlMode = "Ops";
      } else if (displayControlMode == "Ops") {
        displayControlMode = "Time";
      }
      timeOpsToggleButton.innerHTML = displayControlMode;
    }

    //global simulation clock
    var globalSimClock = 0.0;  //starts at zero, units to be specified
    var globalSimUnits = "minutes";
    //globalInsertTime really really really needs to be global
    //storing a value inside the FutureEventsQueue object (referenced by feq) does not reliably hold it
    //used for inserting future event items into the future events queue sorted by activationTime
    var globalInsertTime = 0.0;
    var globalEndTime = 630.0;

    var runToEmptyFlag = true;  //flag for whether to continue running past globalEndTime to empty system
                                 //TODO: would need to determine whether system *can* be emptied
    var finalStatsFlag = false;
    
    var simClockElement = document.getElementById("simClock");
    function updateSimClock(time) {
      globalSimClock = time;
      if ((displayControlMode != "Time") || (displayControlUpdate)) {
        simClockElement.innerHTML = time.toFixed(6) + " " + globalSimUnits;
      }
    }
    updateSimClock(0.0);
    displayControlUpdate = false;
    
    var simProgressText = "";
    var simProgressElement = document.getElementById("simProgress");
    function displayProgressText(textAdd) {
      if (displayControlMode != "Time") {
        simProgressText += textAdd + "\n";  //+ "<br />";
        simProgressElement.innerHTML = simProgressText;
        simProgressElement.scrollTop = simProgressElement.scrollHeight;
      }
    }
    function clearProgressText() {
      simProgressText = "";
      simProgressElement.innerHTML = simProgressText;
    }
    clearProgressText();
    
    var globalComponentIDCounter = 0;
    function getNewComponentID() {
      return ++globalComponentIDCounter;
    }
    var globalEntityIDCounter = 0;
    function getNewEntityID() {
      return ++globalEntityIDCounter;
    }

    var globalExecutionCount = 0;
    function bumpGlobalExecutionCount() {
      globalExecutionCount++;
    }

    //current events queue item
    function CurrentEventItem(entity) {
      this.entity = entity;
      this.checkBlockingCondition = function() {
        return this.entity.checkBlockingCondition(); //true if blocking condition met
      };
    }  //CurrentEventItem

    //the current events queue definition, a list of current events queue items
    function CurrentEventsQueue() {
      this.ceq = []; //new Array();
      this.ceqSize = 0;
      this.addCeqItem = function(ceqItem) {
        this.ceq.push(ceqItem);
        this.ceqSize++;
      };
      //this.removeCeqItem = function(ceqItem) {
      //  var index = this.ceq.indexOf(ceqItem);
      //  this.ceq.splice(index,1);
      //  this.ceqSize--;
      //}
      this.processCeq = function() {
        var trueBlockFound;
        do {
          var i = 0;
          trueBlockFound = false;
          while ((i < this.ceqSize) && (!trueBlockFound)) {
            if (this.ceq[i].checkBlockingCondition()) {
              this.ceq.splice(i,1);
              this.ceqSize--;
              trueBlockFound = true;
            } else {
              i++;
            }
          }
        } while (trueBlockFound);
      };
    }  //CurrentEventsQueue
    
    //the current events queue instantiation
    var ceq = new CurrentEventsQueue();
    
    //future events queue item
    function FutureEventItem(time,entity,nextState,entity2) {
      this.activationTime = 0.0;
      this.entity = entity;
      this.nextState = nextState;
      this.entity2 = entity2;
      if (time >= globalSimClock) {
        this.activationTime = time;                 //activate at specified absolute time, if in future
      } else {
        displayProgressText("Invalid time past time supplied A.  Element ID: "+entity.entityID+" Current Time: "+globalSimClock+" Specified Time: "+time.toFixed(6));  //alert on invalid time
        //alert("Invalid time past time supplied.  Entity ID: "+entity.entityID+" Current Time: "+globalSimClock+" Specified Time: "+time);  //alert on invalid time
      }
      this.getActivationTime = function() {
        return this.activationTime;
      };
      this.getEntity = function() {
        return this.entity;
      };
      this.getNextState = function() {
        return this.nextState;
      };
      this.getEntity2 = function() {
        return this.entity2;
      };
      this.update = function(time,entity,nextState,entity2) {
        this.activationTime = time;
        this.entity = entity;
        this.nextState = nextState;
        this.entity2 = entity2;
      };
    }  //FutureEventItem
    
    var feqCurrent;  //global feqItem
    
    function FutureEventsQueue() {
      this.feq = [];
      this.feqSize = 0;
      this.getFirstItem = function() {
        var feqItem = this.feq.splice(0,1);
        if (feqItem.length) {
          var t = feqItem[0].getActivationTime();
          updateSimClock(t);
          this.feqSize--;
          return feqItem;
        } else {
          //alert("no items in FEQ to retrieve "+this.feqSize);  //probably need to flag end of sim
        }
      };
      this.findLaterTime = function(item) {
        return item.getActivationTime() > globalInsertTime;
      };
      this.insertItem = function(time,type,entity,nextState,entity2) {
        if (type == "advance") {
          time += globalSimClock;
        }
        if (feqCurrent) {
          feqCurrent.update(time,entity,nextState,entity2);
        } else {
          feqCurrent = new FutureEventItem(time,entity,nextState,entity2);
        }
        globalInsertTime = time;  //always uses absolute time
        if (this.feqSize == 0) {  
          this.feq[0] = feqCurrent;
          this.feqSize++;
        } else {
          //find index of feq item to insert before  //findIndex is a native JavaScript method of the Array object
          var insertIndex = this.feq.findIndex(this.findLaterTime);
          //insert the element
          if (insertIndex < 0) {
            insertIndex = this.feq.length;
          }
          this.feq.splice(insertIndex,0,feqCurrent);
          this.feqSize++;
        }
        feqCurrent = null;
      };
    }  //FutureEventsQueue
    
    //initialize future events queue
    var feq = new FutureEventsQueue();

    function advance(byTime,entity,nextState,entity2) {
      feq.insertItem(byTime,"advance",entity,nextState,entity2);
    }  //advance

    function jump(toTime,entity,nextState,entity2) {
      feq.insertItem(toTime,"absolute",entity,nextState,entity2);
    }  //jump

    var keepRunning = true;
    var running = false;
    
    var multiplierButton = document.getElementById("multiplier_button");

    function DisplayControlComponent(displayIncrement,displayEnd) {
      this.displayIncrement = displayIncrement;
      this.displayEnd = displayEnd;
      this.displayClock = globalSimClock;  //assume initialized at time zero
      this.displayMultiplier = 1.0;
      //place the first update request in the queue
      advance(this.displayIncrement * this.displayMultiplier,this,"increment");
      
      this.reset = function() {
        this.displayClock = globalSimClock;
        this.displayMultiplier = 1.0;
        multiplierButton.innerHTML = "x1";
        //place the first update request in the queue
        advance(this.displayIncrement * this.displayMultiplier,this,"increment");
      };
      this.getDisplayMultiplier = function() {
        return this.displayMultiplier;
      };
      this.setDisplayMultiplier = function(displayMultiplier) {
        this.displayMultiplier = displayMultiplier;
      };
      this.increment = function() {
        //update the displays  //&&&&&&&&01
        displayControlUpdate = true;
        
        //if (globalSimClock >= this.displayEnd) {
        if ((globalSimClock >= this.displayEnd) && (!runToEmptyFlag || (setOfEntities.length == 0))) {
          //displayEndMessage();
          keepRunning = false;
        } else {
          //calculate next update time
          var nextTime = this.displayIncrement * this.displayMultiplier;
          while ((this.displayClock + nextTime) < globalSimClock) {
            nextTime += this.displayIncrement * this.displayMultiplier;
          }
          this.displayClock += nextTime;
          advance(nextTime,this,"increment");
        }
      };
      this.activate = function(nextState) {
        if (nextState == "increment") {
          this.increment();
        } else {
          errorUndefinedAdvanceState("DisplayControlComponent",this.nextState);
        }
      };  //this.activate
    }  //DisplayControlComponent
    
    var displayControl = new DisplayControlComponent(0.5,globalEndTime);

    function toggleMultiplier() {
      var multiplierText;
      if (displayControl.getDisplayMultiplier() == 1.0) {
        displayControl.setDisplayMultiplier(2.0);
        multiplierText = "x2";
      } else if (displayControl.getDisplayMultiplier() == 2.0) {
        displayControl.setDisplayMultiplier(1.0);
        multiplierText = "x1";
      }
      multiplierButton.innerHTML = multiplierText;
    }
    
    //entity item 1
/*    function entity1(initialTime,incrementTime,endTime,destination) {
      this.entityID = getNewEntityID();
      this.initialTime = initialTime;
      this.incrementTime = incrementTime;
      this.endTime = endTime;
      //this.nextState = "destination";
      feq.newItem(initialTime,this,"destination");
      displayProgressText("entity "+this.entityID+" created at time "+globalSimClock.toFixed(6));
      this.activate = function(nextState) {
        if (nextState == "destination") {
          displayProgressText("entity "+this.entityID+" updated at time "+globalSimClock.toFixed(6));
          //set values for display-------------
          //displayStartTime = globalSimClock;
          displayCurrentTime = globalSimClock;
          //displayEndTime = globalSimClock + this.incrementTime;
          //displayEntitiesScheduled = arrivals;
          displayentitiesScheduled++;
          displayEntityID = this.entityID;
          initBallFlag = true;
          displayActivity = "new entity";
          //----------------------------------
          if (globalSimClock + this.incrementTime >= this.endTime) {
            //this.nextState = "destroy";
            advance(this.incrementTime,"destroy");
          } else {
            advance(this.incrementTime,"destination");
          }
        } else if (nextState == "destroy") {
          displayProgressText("entity "+this.entityID+" terminated at time "+globalSimClock.toFixed(6));
          //set values for diplay-------------
          //displayStartTime = globalSimClock;
          displayCurrentTime = globalSimClock;
          //displayEndTime = globalSimClock + this.incrementTime;
          //displayEntitiesScheduled = arrivals;
          //displayentitiesScheduled++;
          displayEntityID = this.entityID;
          initBallFlag = false;
          displayActivity = "terminated";
          //----------------------------------
        } else {
          alert("entity "+this.entityID+" went into undefined state");
          displayProgressText("entity "+this.entityID+" in undefined state at time "+globalSimClock.toFixed(6));
        }
      };  //this.activate      
    };  //entity
*/
    function errorUndefinedAdvanceState(id,state) {
      //alert("entity "+id+" went into undefined state");
      displayProgressText("entity "+id+" in undefined state: "+state+", at time "+globalSimClock.toFixed(6));
    }
//entity item 2
/*    function entity2(initialTime,initialPosition,speed,endPosition) {
      this.entityID = getNewComponentID();
      this.initialTime = initialTime;
      this.currentPosition = initialPosition;
      this.speed = speed;
      this.endPosition = endPosition;
      //this.nextState = "go_forward";
      this.waitCountdown = 5;
      feq.newItem(initialTime,this,"go_forward");
      displayProgressText("entity "+this.entityID+" created at time "+globalSimClock.toFixed(6));
      this.go_forward = function() {
        displayProgressText("entity "+this.entityID+" updated at time "+globalSimClock+" position: "+this.currentPosition);
        this.currentPosition += this.speed;
        if (this.currentPosition >= this.endPosition) {
          if (this.currentPosition > this.endPosition) {
            this.currentPosition = this.endPosition;
          }
          //this.nextState = "wait";
          advance(7.01,"wait");      
        } else {
          advance(7.01,"go_forward");
        }
      }
      this.wait = function() {
        this.waitCountdown--;
        displayProgressText("entity "+this.entityID+" waiting at time "+globalSimClock+" wait count: "+this.waitCountdown);
        if (this.waitCountdown <= 0.0) {
          //this.nextState = "destroy";
          advance(7.01,"destroy");      
        } else {
          advance(7.01,"wait");
        }
      }
      this.destroy = function() {
         displayProgressText("entity "+this.entityID+" terminated at time "+globalSimClock.toFixed(6));
      }
      this.activate = function(nextState) {
        bumpGlobalExecutionCount();
        if (nextState == "go_forward") {
          this.go_forward();
        } else if (nextState == "wait") {
          this.wait();
        } else if (nextState == "destroy") {
          this.destroy();
        } else {
          errorUndefinedAdvanceState(this.entityID,nextState);
        }
      };  //this.activate      
    };  //entity2
*/
    //entity item 2a
/*    function entity2a(initialTime,initialPosition,speed,endPosition) {
      var go_forward_ = 0;
      var wait_ = 1;         //define named index values for clarity
      var destroy_ = 2;
      this.entityID = getNewComponentID();
      this.initialTime = initialTime;
      this.currentPosition = initialPosition;
      this.speed = speed;
      this.endPosition = endPosition;
      //this.nextState = go_forward_;
      this.waitCountdown = 5;
      feq.newItem(initialTime,this,go_forward_);
      displayProgressText("entity "+this.entityID+" created at time "+globalSimClock.toFixed(6));
      this.go_forward = function(entity) {
        displayProgressText("entity "+this.entityID+" updated at time "+globalSimClock+" position: "+this.currentPosition);
        this.currentPosition += this.speed;
        if (this.currentPosition >= this.endPosition) {
          if (this.currentPosition > this.endPosition) {
            this.currentPosition = this.endPosition;
          }
          //this.nextState = wait_;
          advance(7.01,wait_);      
        } else {
          advance(7.01,go_forward_);
        }
      }
      this.wait = function() {
        this.waitCountdown--;
        displayProgressText("entity "+this.entityID+" waiting at time "+globalSimClock+" wait count: "+this.waitCountdown);
        if (this.waitCountdown <= 0.0) {
          //this.nextState = destroy_;
          advance(7.01,destroy_);      
        } else {
          advance(7.01,wait_);
        }
      }
      this.destroy = function() {
        displayProgressText("entity "+this.entityID+" terminated at time "+globalSimClock.toFixed(6));
      }
      //define the array of functions here
      this.activateArray = [this.go_forward,this.wait,this.destroy];
      this.activate = function(nextState) {
        bumpGlobalExecutionCount();
        if ((nextState >= 0) && (nextState <= 2)) {
          //call the desired function this way
          this.activateArray[nextState]();
        } else {
          errorUndefinedAdvanceState(this.entityID,nextState);
        }
      };  //this.activate      
    };  //entity2a
*/
    //entity item 3
/*    function entity3(initialTime,executionCount) {
      this.entityID = getNewComponentID();
      this.initialTime = initialTime;
      this.executionCount = executionCount;
      //this.nextState = "block1";
      //feq.newItem(initialTime,this);
      this.ceqItem = new CurrentEventItem(this);
      ceq.addCeqItem(this.ceqItem);
      displayProgressText("entity "+this.entityID+" created at time "+globalSimClock.toFixed(6));
      this.blockingCondition = 0;
      this.checkBlockingCondition = function() {
        if (this.blockingCondition < 0) {
          return false;
        } else if (this.blockingCondition == 0) {
          var fred = globalExecutionCount % this.executionCount;
          if (Math.abs(fred) <= 0.00001) {
            displayProgressText("entity "+this.entityID+" reports at time "+globalSimClock+" executions: "+globalExecutionCount);
            return true;
          } else {
            return false;
          }
        } 
      }
//      this.activate = function(nextState) {
//        if (nextState == "block1") {
//          displayProgressText("entity "+this.entityID+" checking blocks at time "+globalSimClock+" blockState: "+this.blockingCondition);
//          ceq.addItem(this.ceqItem);
//        } else {
//          alert("entity "+this.entityID+" went into undefined state");
//          displayProgressText("entity "+this.entityID+" in undefined state at time "+globalSimClock.toFixed(6));
//        }
//      };  //this.activate
    };  //entity3
*/
    function ConditionFlag(flag) {
      this.flag = flag;
      this.getFlag = function() {
        return this.flag;
      };
      this.setFlag = function(flag) {
        this.flag = flag;
      };
    }
    var flag1 = new ConditionFlag(false);
    var flag2 = new ConditionFlag(false);
    
    //entity item 4
/*    function entity4(initialTime,incrementTime,endTime,flagPointer) {
      this.entityID = getNewComponentID();
      this.initialTime = initialTime;
      this.incrementTime = incrementTime;
      this.endTime = endTime;
      this.flagPointer = flagPointer;
      //this.nextState = "increment";
      feq.newItem(initialTime,this,"increment");
      displayProgressText("entity "+this.entityID+" created at time "+globalSimClock.toFixed(6));
      this.activate = function(nextState) {
        bumpGlobalExecutionCount();
        if (nextState == "increment") {
          displayProgressText("entity "+this.entityID+" sets flag at time "+globalSimClock.toFixed(6)+" flag value: "+this.flagPointer.getFlag()+" flag1: "+flag1.getFlag()+" flag2: "+flag2.getFlag());
          if (globalSimClock + this.incrementTime >= this.endTime) {
            this.nextState = "destroy";
            advance(this.incrementTime,"destroy");
          } else {
            advance(this.incrementTime,"increment");
          }
        } else if (nextState == "destroy") {
          this.flagPointer.setFlag(true);
          displayProgressText("entity "+this.entityID+" terminated at time "+globalSimClock.toFixed(6)+" flag value: "+this.flagPointer.getFlag()+" flag1: "+flag1.getFlag()+" flag2: "+flag2.getFlag());
        } else {
          alert("entity "+this.entityID+" went into undefined state");
          displayProgressText("entity "+this.entityID+" in undefined state at time "+globalSimClock.toFixed(6));
        }
      };  //this.activate      
    };  //entity
*/
    //entity item 5
/*    function entity5(initialTime,flagPointer) {
      this.entityID = getNewComponentID();
      this.initialTime = initialTime;
      this.flagPointer = flagPointer;
      //this.nextState = "block1";
      //feq.newItem(initialTime,this);
      this.ceqItem = new CurrentEventItem(this);
      ceq.addCeqItem(this.ceqItem);
      displayProgressText("entity "+this.entityID+" created at time "+globalSimClock.toFixed(6));
      this.blockingCondition = 0;
      this.checkBlockingCondition = function() {
        if (this.blockingCondition < 0) {
          return false;
        } else if (this.blockingCondition == 0) {
          if (this.flagPointer.getFlag()) {
            displayProgressText("entity "+this.entityID+" unblocks at time "+globalSimClock.toFixed(6)+" flag value: "+this.flagPointer.getFlag());
            return true;
          } else {
            displayProgressText("entity "+this.entityID+" still blocked at time "+globalSimClock.toFixed(6)+" flag value: "+this.flagPointer.getFlag()+" flag1: "+flag1.getFlag()+" flag2: "+flag2.getFlag());
            return false;
          }
        } 
      }
    };  //entity5
*/
    //entity item with display //not currently used
/*    function entityWithDisplay(initialTime,incrementTime,endTime) {
      this.entityID = getNewComponentID();
      this.initialTime = initialTime;
      this.incrementTime = incrementTime;
      this.endTime = endTime;
      //this.nextState = "initialize";  //first activation: become visible 
      feq.newItem(initialTime,this,"initialize");
      displayProgressText("entity "+this.entityID+" created at time "+globalSimClock.toFixed(6));
      this.initialize = function() {
        
      }
      this.increment = function() {
        displayProgressText("entity "+this.entityID+" updated at time "+globalSimClock.toFixed(6));
        //set values for diplay-------------
        //displayStartTime = globalSimClock;
        displayCurrentTime = globalSimClock;
        //displayEndTime = globalSimClock + this.incrementTime;
        //displayEntitiesScheduled = arrivals;
        displayentitiesScheduled++;
        displayEntityID = this.entityID;
        initBallFlag = true;
        displayActivity = "new entity";
        //----------------------------------
        if (globalSimClock + this.incrementTime >= this.endTime) {
          //this.nextState = "destroy";
          advance(this.incrementTime,"destroy");
        } else {
          advance(this.incrementTime,"increment");
        }      
      }
      this.destroy = function() {
        displayProgressText("entity "+this.entityID+" terminated at time "+globalSimClock.toFixed(6));
        //set values for display-------------
        //displayStartTime = globalSimClock;
        displayCurrentTime = globalSimClock;
        //displayEndTime = globalSimClock + this.incrementTime;
        //displayEntitiesScheduled = arrivals;
        //displayentitiesScheduled++;
        displayEntityID = this.entityID;
        initBallFlag = false;
        displayActivity = "terminated";
        //----------------------------------      
      }
      this.activate = function(nextState) {
        if (nextState == "initialize") {
          this.initialize();
        } else if (nextState == "increment") {
          this.increment();
        } else if (nextState == "destroy") {
          this.destroy();
        } else {
          errorUndefinedAdvanceState(this.entityID,nextState);
        }
      };  //this.activate
    };  //entity
*/
//*****************************************************************************
//*** Collect model run stats
//*****************************************************************************
    var groupStatsNamesList = [];
    var statsArrayGlobal;
    var statsArrayCitizen;
    var statsArrayLPR;
    var statsArrayVisitor;
    var statsTimeIndex = 0;
    var statsUpdateInterval = 30;
    
    function initStatsArrays() {
      statsArrayGlobal = [];
      statsArrayCitizen = [];
      statsArrayLPR = [];
      statsArrayVisitor = [];
    }
    initStatsArrays();
    
    function incrementStatsTimeIndex(whichStatsArray) {
      var length = groupStatsNamesList.length;
      for (var i=0; i<length; i++) {
        if (statsTimeIndex > 0) {
          var currentCount = whichStatsArray[i][statsTimeIndex-1][4];  //bring the running count of entities in the system forward
          whichStatsArray[i].push([0,0,0,Infinity,currentCount,currentCount,currentCount]);  //only for elements greater than zero
        } else if (statsTimeIndex == 0) {
          whichStatsArray[i] = [];
          whichStatsArray[i].push([0,0,0,Infinity,0,0,Infinity]);  //zeroth element only
        }
      }
    }
    
    function incrementStatsTimeIndexWrapper() {
      statsTimeIndex++;
      incrementStatsTimeIndex(statsArrayGlobal);   //global stats  
      incrementStatsTimeIndex(statsArrayCitizen);  //citizen stats  
      incrementStatsTimeIndex(statsArrayLPR);      //lpr stats  
      incrementStatsTimeIndex(statsArrayVisitor);  //visitor stats  
    }
    
    function getIndexOfGroupStatsItem(groupName) {
      var length = groupStatsNamesList.length;
      for (var i=0; i<length; i++) {
        if (groupStatsNamesList[i] == groupName) {
          return i;
        }
      }
      return -1;
    }
    
    function addToGroupStatsNameList(whichStatsArray,groupName) {  //TODO: review use of groupName here, is it needed?
      whichStatsArray[groupStatsNamesList.length-1] = [];
      whichStatsArray[groupStatsNamesList.length-1].push([0,0,0,Infinity,0,0,Infinity]);  //zeroth element only
    }
    
    function addToGroupStatsNameListWrapper(groupName) {
      if (getIndexOfGroupStatsItem(groupName) < 0) {
        groupStatsNamesList.push(groupName);
        addToGroupStatsNameList(statsArrayGlobal,groupName);
        addToGroupStatsNameList(statsArrayCitizen,groupName);
        addToGroupStatsNameList(statsArrayLPR,groupName);
        addToGroupStatsNameList(statsArrayVisitor,groupName);
      }
    }

    function recordGroupStats(whichStatsArray,groupName,beginTime) {
      var elapsedTime = globalSimClock - beginTime;
      var index = getIndexOfGroupStatsItem(groupName);
      if (index >= 0) {
        whichStatsArray[index][statsTimeIndex][0]++;  //number of entries
        whichStatsArray[index][statsTimeIndex][1] += elapsedTime;  //elapsed time accumulator
        if (elapsedTime > whichStatsArray[index][statsTimeIndex][2]) {
          whichStatsArray[index][statsTimeIndex][2] = elapsedTime;  //highest elapsed time
        }
        if (elapsedTime < whichStatsArray[index][statsTimeIndex][3]) {
          whichStatsArray[index][statsTimeIndex][3] = elapsedTime;  //lowest elapsed time
        }
        whichStatsArray[index][statsTimeIndex][4]--; // number of entities in system at time of recording
        if (whichStatsArray[index][statsTimeIndex][4] > whichStatsArray[index][statsTimeIndex][5]) {
          whichStatsArray[index][statsTimeIndex][5] = whichStatsArray[index][statsTimeIndex][4];  //highest count in system
        }
        if (whichStatsArray[index][statsTimeIndex][4] < whichStatsArray[index][statsTimeIndex][6]) {
          whichStatsArray[index][statsTimeIndex][6] = whichStatsArray[index][statsTimeIndex][4];  //lowest count in system
        }
      } else {
        alert("Tried to add stats to nonexistent name: "+groupName);
      }
    }  //recordGroupStats

    function recordGroupStatsWrapper(groupName,beginTime,entity) {
      recordGroupStats(statsArrayGlobal,groupName,beginTime);
      
      var targetStatsArray;
      if (entity.getPropertyValue("Residency") == "Citizen") {
        targetStatsArray = statsArrayCitizen;
      } else if (entity.getPropertyValue("Residency") == "LPR") {
        targetStatsArray = statsArrayLPR;
      } else if (entity.getPropertyValue("Residency") == "Visitor") {
        targetStatsArray = statsArrayVisitor;
      }
      recordGroupStats(targetStatsArray,groupName,beginTime);
    }
    
    function recordGroupStatsSystemEntry(whichStatsArray,groupName) {
      var index = getIndexOfGroupStatsItem(groupName);
      if (index >= 0) {
        whichStatsArray[index][statsTimeIndex][4]++;  // number of entities in system at time of recording
        if (whichStatsArray[index][statsTimeIndex][4] > whichStatsArray[index][statsTimeIndex][5]) {
          whichStatsArray[index][statsTimeIndex][5] = whichStatsArray[index][statsTimeIndex][4];  //highest count in system
        }
        if (whichStatsArray[index][statsTimeIndex][4] < whichStatsArray[index][statsTimeIndex][6]) {
          whichStatsArray[index][statsTimeIndex][6] = whichStatsArray[index][statsTimeIndex][4];  //lowest count in system
        }
      }
    }

    function recordGroupStatsSystemEntryWrapper(groupName,entity) {
      recordGroupStatsSystemEntry(statsArrayGlobal,groupName);
      
      var targetStatsArray;
      if (entity.getPropertyValue("Residency") == "Citizen") {
        targetStatsArray = statsArrayCitizen;
      } else if (entity.getPropertyValue("Residency") == "LPR") {
        targetStatsArray = statsArrayLPR;
      } else if (entity.getPropertyValue("Residency") == "Visitor") {
        targetStatsArray = statsArrayVisitor;
      }
      recordGroupStatsSystemEntry(targetStatsArray,groupName);
    }

    function formatString(number,decimals,width) {
      var s = number.toFixed(decimals);
      var length = s.length;
      for (var i=length; i<width; i++) {
        s = " " + s;
      }
      return s;
    }
    
    function reportStats(whichStatsArray,reportTitle) {  //reportTitle is a string based on entity type
      var oldDisplayControlMode = displayControlMode;
      displayControlMode = "Ops";

      var i;
      var s;
      var samples;
      var averageTime;
      
      var intervalCount = statsTimeIndex;
      displayProgressText(reportTitle);
      displayProgressText("Tabulated Results");
      displayProgressText("");
      var length = groupStatsNamesList.length;
      for (i = 0; i < length; i++) {
        //initialize the accumulators
        whichStatsArray[i][intervalCount][0] = 0;
        whichStatsArray[i][intervalCount][1] = 0;
        whichStatsArray[i][intervalCount][2] = 0;
        whichStatsArray[i][intervalCount][3] = Infinity;
        whichStatsArray[i][intervalCount][4] = 0;
        whichStatsArray[i][intervalCount][5] = 0;
        whichStatsArray[i][intervalCount][6] = Infinity;
        
        displayProgressText(groupStatsNamesList[i]);
        displayProgressText("  Time Exits   AvgTm  MaxTm  MinTm  Size  Max  Min");
        for (var j = 0; j <= intervalCount; j++) {
          //tabulate totals
          if (j < intervalCount) {
            //condition the values
            samples = whichStatsArray[i][j][0];
            if (samples > 0) {
              averageTime = whichStatsArray[i][j][1] / samples;
            } else {
              averageTime = 0.0;
            }
            if (samples > 0) {
              if (whichStatsArray[i][j][3] == Infinity) {
                whichStatsArray[i][j][3] = 0;
              }
            } else {
              whichStatsArray[i][j][2] = 0;
              whichStatsArray[i][j][3] = 0;
            }
            if (whichStatsArray[i][j][6] == Infinity) {
              whichStatsArray[i][j][6] = 0;
            }

            //process the interval values
            whichStatsArray[i][intervalCount][0] += whichStatsArray[i][j][0];
            whichStatsArray[i][intervalCount][1] += whichStatsArray[i][j][1];
            if (whichStatsArray[i][j][2] > whichStatsArray[i][intervalCount][2]) {
              whichStatsArray[i][intervalCount][2] = whichStatsArray[i][j][2];
            }
            if (whichStatsArray[i][j][3] < whichStatsArray[i][intervalCount][3]) {
              whichStatsArray[i][intervalCount][3] = whichStatsArray[i][j][3];
            }
            if (whichStatsArray[i][j][4] > whichStatsArray[i][intervalCount][4]) {
              whichStatsArray[i][intervalCount][4] = whichStatsArray[i][j][4];
            }
            if (whichStatsArray[i][j][5] > whichStatsArray[i][intervalCount][5]) {
              whichStatsArray[i][intervalCount][5] = whichStatsArray[i][j][5];
            }
            if (whichStatsArray[i][j][6] < whichStatsArray[i][intervalCount][6]) {
              whichStatsArray[i][intervalCount][6] = whichStatsArray[i][j][6];
            }
          } else {
            //calculate the final values
            if (whichStatsArray[i][intervalCount][0] > 0) {
              averageTime = whichStatsArray[i][intervalCount][1] / whichStatsArray[i][intervalCount][0];
            } else {
              averageTime = 0.0;
            }
          }
          
          //build the display string
          if (j < (intervalCount-1)) {
            s = formatString(((j+1) * statsUpdateInterval),0,6) + " ";          
          } else if (j < intervalCount) {
            s = formatString(globalSimClock,0,6) + " ";
          } else {
            s = "  Total";
          }
          s += formatString(whichStatsArray[i][j][0],0,5) + " ";
          s += formatString(averageTime,1,7) + " ";
          s += formatString(whichStatsArray[i][j][2],1,6) + " ";
          s += formatString(whichStatsArray[i][j][3],1,6) + " ";
          s += formatString(whichStatsArray[i][j][4],0,5) + " ";
          s += formatString(whichStatsArray[i][j][5],0,4) + " ";
          s += formatString(whichStatsArray[i][j][6],0,4);
          displayProgressText(s);
        }
        
        displayProgressText("");
      }

      displayControlMode = oldDisplayControlMode;
    }  //reportStats

    function reportStatsWrapper() {
      //incrementStatsTimeIndexWrapper();  //do this in once before and outside of this function as it's called multiple times
      reportStats(statsArrayGlobal,"All Entities");
      reportStats(statsArrayCitizen,"Citizens");
      reportStats(statsArrayLPR,"LPRs");
      reportStats(statsArrayVisitor,"Visitors");
    }
    
    function StatsTimerComponent(statsInterval, timeEnd) {
      this.statsInterval = statsInterval;
      this.timeEnd = timeEnd;
      //place the first update request in the queue
      advance(statsInterval, this, "increment");

      this.reset = function() {
        initStatsArrays();
        statsTimeIndex = -1;
        incrementStatsTimeIndexWrapper();
        //place the first update request in the queue
        advance(statsInterval, this, "increment");
      };
      this.increment = function() {
        incrementStatsTimeIndexWrapper();
        if ((globalSimClock < this.timeEnd) || 
            (!runToEmptyFlag) || 
            ((globalSimClock >= this.timeEnd) && runToEmptyFlag && (setOfEntities.length > 0))
           ) {
        //if (globalSimClock < this.timeEnd) {
           advance(statsInterval, this, "increment");
        } else {  //TODO: clear this out
          //finalStatsFlag = true;
          
        }
      };
      this.activate = function(nextState) {
        if (nextState == "increment") {
          this.increment();
        } else {
          errorUndefinedAdvanceState("StatsTimerComponent", this.nextState);
        }
      };  //this.activate
    }  //StatsTimerComponent

    var statsTimer = new StatsTimerComponent(statsUpdateInterval, globalEndTime);
//*****************************************************************************
//*** General graphic functions
//*****************************************************************************
    function drawNode(x, y, r, c) {
      globalCTX.strokeStyle = c;
      globalCTX.beginPath();
      globalCTX.arc(x, y, r, 0, 2 * Math.PI, true);
      globalCTX.stroke();
      globalCTX.fillStyle = c;
      globalCTX.fill();
    }

//*****************************************************************************
//*** Entity definitions
//*****************************************************************************
    //global entity properties
    var entityProperties = [];
    var numEntityProperties = 0;

    function defineEntityProperty(propertyName,property) {
      var i = 0;

      while ((i < numEntityProperties) && (propertyName != entityProperties[i][0])) {
        i++;
      }
      if (i < numEntityProperties) {
        //propertyName already in list, add property
        entityProperties[i].push(property);
      } else {
        var p = [];
        p[0] = propertyName;
        p[1] = property;
        entityProperties.push(p);
        numEntityProperties++;
      }
    }

    //entity item passive
    //stores minimal state information, does nothing on its won
    function EntityPassive(entityType,parentEntity) {
      if (typeof parentEntity === "undefined") {parentEntity = null}
      this.entityID = getNewEntityID();
      this.entryTime = globalSimClock;
      this.entityType = entityType;
      var p = [];
      for (var i=0; i<numEntityProperties; i++) {
        p[i] = 0;
      }
      this.propertyList = p;
      this.entityColor = "#FFFFFF";  //default color, should set this based on its properties
      this.localEntryTime = 0.0;
      this.localIndex = -1;
      this.componentGroup = "";
      this.componentGroupEntryTime = 0.0;
      this.xLocation = 0.0;
      this.yLocation = 0.0;
      this.permissionToMove = false;
      this.forwardAttemptTime = Infinity;
      this.parentEntity = parentEntity;
/*      this.getEntityID = function() {
        return this.entityID;
      };
      this.getEntryTime = function() {
        return this.entryTime;
      };
      this.setLocalEntryTime = function() {
        this.localEntryTime = globalSimClock;
      };
      this.getLocalEntryTime = function() {
        return this.localEntryTime;
      };
      this.setLocalIndex = function(index) {
        this.localIndex = index;
      }
      this.getLocalIndex = function() {
        return this.localIndex;
      }
      this.setComponentGroup = function(componentGroup) {
        this.componentGroup = componentGroup;
      };
      this.getComponentGroup = function() {
        return this.componentGroup;
      };
      this.setComponentGroupEntryTime = function(componentGroupEntryTime) {
        this.componentGroupEntryTime = componentGroupEntryTime;
      };
      this.getComponentGroupEntryTime = function() {
        return this.componentGroupEntryTime;
      };
      this.getEntityType = function() {
        return this.entityType;
      };
      this.setPropertyValue = function(propertyName,propertyValue) {
        var i = 0;

        while ((i < numEntityProperties) && (propertyName != entityProperties[i][0])) {
          i++;
        }
        if (i < numEntityProperties) {
          this.propertyList[i] = propertyValue;
        } else {
          alert("Trying to set out of range entity property");
        }
      };
      this.getPropertyValue = function(propertyName) {
        var i = 0;

        while ((i < numEntityProperties) && (propertyName != entityProperties[i][0])) {
          i++;
        }
        if (i < numEntityProperties) {
          return this.propertyList[i];
        } else {
          alert("Trying to get out of range entity property");
        }
      };
      this.setLocation = function(xloc, yloc) {
        this.xLocation = xloc;
        this.yLocation = yloc;
      };
      this.getLocation = function() {
        return {x: this.xLocation, y: this.yLocation};
      };
      this.setPermission = function(permission) {
        this.permissionToMove = permission;
      };
      this.getPermission = function() {
        return this.permissionToMove;
      };
      this.getForwardAttemptTime = function() {
        return this.forwardAttemptTime;
      };
      this.setForwardAttemptTime = function(forwardAttemptTime) {
        this.forwardAttemptTime = forwardAttemptTime;
      };
      this.setEntityColor = function(color) {
        this.entityColor = color;
      };
      this.getEntityColor = function() {
        return this.entityColor;
      };
      this.drawEntity = function() {  //(entityColor) {
        //in this case x and y are absolute screen coords
        drawNode(this.xLocation, this.yLocation, 5, this.entityColor);
      };  */
    }  //EntityPassive
    EntityPassive.prototype.getEntityID = function() {
      return this.entityID;
    };
    EntityPassive.prototype.getEntryTime = function() {
      return this.entryTime;
    };
    EntityPassive.prototype.setLocalEntryTime = function() {
      this.localEntryTime = globalSimClock;
    };
    EntityPassive.prototype.getLocalEntryTime = function() {
      return this.localEntryTime;
    };
    EntityPassive.prototype.setLocalIndex = function(index) {
      this.localIndex = index;
    };
    EntityPassive.prototype.getLocalIndex = function() {
      return this.localIndex;
    };
    EntityPassive.prototype.setComponentGroup = function(componentGroup) {
      this.componentGroup = componentGroup;
    };
    EntityPassive.prototype.getComponentGroup = function() {
      return this.componentGroup;
    };
    EntityPassive.prototype.setComponentGroupEntryTime = function(componentGroupEntryTime) {
      this.componentGroupEntryTime = componentGroupEntryTime;
    };
    EntityPassive.prototype.getComponentGroupEntryTime = function() {
      return this.componentGroupEntryTime;
    };
    EntityPassive.prototype.getEntityType = function() {
      return this.entityType;
    };
    EntityPassive.prototype.setPropertyValue = function(propertyName,propertyValue) {
      var i = 0;

      while ((i < numEntityProperties) && (propertyName != entityProperties[i][0])) {
        i++;
      }
      if (i < numEntityProperties) {
        this.propertyList[i] = propertyValue;
      } else {
        alert("Trying to set out of range entity property");
      }
    };
    EntityPassive.prototype.getPropertyValue = function(propertyName) {
      var i = 0;

      while ((i < numEntityProperties) && (propertyName != entityProperties[i][0])) {
        i++;
      }
      if (i < numEntityProperties) {
        return this.propertyList[i];
      } else {
        alert("Trying to get out of range entity property");
      }
    };
    EntityPassive.prototype.setLocation = function(xloc, yloc) {
      this.xLocation = xloc;
      this.yLocation = yloc;
    };
    EntityPassive.prototype.getLocation = function() {
      return {x: this.xLocation, y: this.yLocation};
    };
    EntityPassive.prototype.setPermission = function(permission) {
      this.permissionToMove = permission;
    };
    EntityPassive.prototype.getPermission = function() {
      return this.permissionToMove;
    };
    EntityPassive.prototype.getForwardAttemptTime = function() {
      return this.forwardAttemptTime;
    };
    EntityPassive.prototype.setForwardAttemptTime = function(forwardAttemptTime) {
      this.forwardAttemptTime = forwardAttemptTime;
    };
    EntityPassive.prototype.setEntityColor = function(color) {
      this.entityColor = color;
    };
    EntityPassive.prototype.getEntityColor = function() {
      return this.entityColor;
    };
    EntityPassive.prototype.drawEntity = function() {  //(entityColor) {
      //in this case x and y are absolute screen coords
      drawNode(this.xLocation, this.yLocation, 5, this.entityColor);
    };

    defineEntityProperty("Process Speed","Fast");
    defineEntityProperty("Process Speed","Slow");
    defineEntityProperty("Residency","Citizen");
    defineEntityProperty("Residency","LPR");
    defineEntityProperty("Residency","Visitor");
    defineEntityProperty("Base Type","Main");
    defineEntityProperty("Base Type","Spawn");

    //collection of all entities in the system
    var setOfEntities = [];  //new Array();
    //collection of all components in the system
    var setOfComponents = [];

    function removeEntityFromList(entityID) {
      var i = 0;
      while (setOfEntities[i].entityID != entityID) {
        i++;
      }
      if (i < setOfEntities.length) {
        setOfEntities.splice(i, 1);
      }
    }

    function compareNumeric(a, b) {
      return a - b;
    }

    //function to generate new entities
    //version using start parameter meant for waking up active entities
    //generateNewEntity = function(generator,start) {
    //function generateNewEntity(generator) {
    function generateNewEntity(parentEntity) {
      if (typeof parentEntity === "unknown") {parentEntity = null}
      //generator is an arrivals component
      //start is an initial activation time
      var newEntity = new EntityPassive(0, parentEntity);  //all are type 0 for now
      setOfEntities.push(newEntity);
      return newEntity;
    }  //generateNewEntity
    
    function assignEntityTypes(entity) {
      //we have to create some custom code here
      var result = Math.random();
      var speed;
      if (result <= 0.3) {
        entity.setPropertyValue("Process Speed","Fast");
        speed = 1;
      } else if (result <= 1.0) {
        entity.setPropertyValue("Process Speed","Slow");
        speed = 2;
      }  //skip testing other possibilities
      result = Math.random();
      if (result < 0.65) {
        entity.setPropertyValue("Residency","Citizen");
        if (speed == 1) {
          entity.setEntityColor("#0000FF");
        } else {
          entity.setEntityColor("#000088");
        }
      } else if (result < 0.75) {
        entity.setPropertyValue("Residency","LPR");
        if (speed == 1) {
          entity.setEntityColor("#FF00FF");
        } else {
          entity.setEntityColor("#880088");
        }
      } else if (result < 1.0) {
        entity.setPropertyValue("Residency","Visitor");
        if (speed == 1) {
          entity.setEntityColor("#FFFF00");
        } else {
          entity.setEntityColor("#888800");
        }
      }
      entity.setPropertyValue("Base Type","Main");
    }
    
    function entityProcessTimeIndex(entity,switchIndex) {
      var index;
      if (switchIndex == 0) {  //primary
        if (entity.getPropertyValue("Process Speed") == "Fast") {
          index = 0;
        } else if (entity.getPropertyValue("Residency") == "Visitor") {
          index = 1;
        } else {
          index = 2;
        }
      } else if (switchIndex == 1) {  //parking lot
        if (entity.getPropertyValue("Residency") == "Citizen") {
          index = 0;
        } else if (entity.getPropertyValue("Residency") == "LPR") {
          index = 1;
        } else if (entity.getPropertyValue("Residency") == "Visitor") {
          index = 2;
        }
      }
      return index;
    }
    
    function entityDiversionPercentIndex(entity) {
      var index;
      if (entity.getPropertyValue("Residency") == "Citizen") {
        index = 0;
      } else if (entity.getPropertyValue("Residency") == "LPR") {
        index = 1;
      } else if (entity.getPropertyValue("Residency") == "Visitor") {
        index = 2;
      }
      return index;
    }

//*****************************************************************************
//*** Component definitions
//*****************************************************************************
    //Arrivals component: generates entities that will be processed by the model
    function ArrivalsComponent(scheduleBlockMinutes, scheduleArray, entryDistributionArray) {
      //exclusivity doesn't matter
      setOfComponents.push(this);
      this.componentID = getNewComponentID();
      this.componentType = "Arrivals";  //"";
      this.componentName = "Arrivals";  //"";
      this.nextComponentList = [];
      this.nextComponentCount = 0;
      this.incrementTime = scheduleBlockMinutes;
      this.entryEntityID = "";
      this.displayDelay = 0;
      this.activity = "creation";

      this.startBlockTime = globalSimClock;
      this.currentBlockTime = globalSimClock;
      this.endBlockTime = globalSimClock + this.incrementTime;
      this.entitiesScheduled = 0;
      this.entitiesRemaining = 0;
      this.scheduleIndex = -1;
      //this.graphic = null;

      jump(globalSimClock, this, "increment");    //assume all components created at time zero

      this.reset = function() {
        this.entryEntityID = "";
        this.activity = "creation";
        this.startBlockTime = globalSimClock;
        this.currentBlockTime = globalSimClock;
        this.endBlockTime = globalSimClock + this.incrementTime;
        this.entitiesScheduled = 0;
        this.entitiesRemaining = 0;
        this.scheduleIndex = -1;
        jump(globalSimClock, this, "increment");  //assume all components created at time zero //TODO-: figure out if this kicks everything off and if this is the right way to do it
      };
      this.assignNextComponent = function(next) {  //ArrivalsComponent
        this.nextComponentList.push(next);
        this.nextComponentCount++;
        //no need to assign next-previous
      };
      this.verifyLinks = function() {
        var error = "";
        if (this.nextComponentCount > 0) {
          for (var i = 0; i < this.nextComponentCount; i++) {  //>
            if (this.nextComponentList[i]) {  //link exists
              if (typeof this.nextComponentList[i] === "object") {  //link points to an object
                if ("componentType" in this.nextComponentList[i]) {  //object contains member componentType
                  if (this.nextComponentList[i].componentType != "Entry") {  //link points to an arrivals object
                    error += this.componentType + " comp. " + this.componentID + " next comp. list element " + i + " is not an Entry comp.\n";
                  }
                } else {
                  //linked object does not contain member componentType
                  error += this.componentType + " comp. " + this.componentID + " next comp. list item " + i + " does not have componentType\n";
                }
              } else {
                //link points to something that is not an object
                error += this.componentType + " comp. " + this.componentID + " next comp. list item " + i + " is not an object\n";
              }
            } else {
              //link that should exist does not
              error += this.componentType + " comp. " + this.componentID + " next comp. list item " + i + " does not exist\n";
            }
          }
        } else {
          error += this.componentType + " comp. " + this.componentID + " has index of zero next components\n";
        }
        return error;
      };

      this.getComponentID = function() {
        return this.componentID;
      };
      this.getComponentType = function() {  //ArrivalsComponent
        return this.componentType;
      };
      this.getComponentName = function() {
        return this.componentName;
      };
      this.setComponentName = function(componentName) {
        this.componentName = componentName;
      };
      this.getIncrementTime = function() {
        return this.incrementTime;
      };
      this.getEntryEntityID = function() {
        return this.entryEntityID;
      };
      this.getActivity = function() {
        return this.activity;
      };
      this.getStartBlockTime = function() {
        return this.startBlockTime;
      };
      this.getCurrentBlockTime = function() {
        return this.currentBlockTime;
      };
      this.getEndBlockTime = function() {
        return this.endBlockTime;
      };
      this.getEntitiesScheduled = function() {
        return this.entitiesScheduled;
      };
      this.getEntitiesRemaining = function() {
        return this.entitiesRemaining;
      };
      this.getScheduleIndex = function() {
        return this.scheduleIndex;
      };

      this.dataGroup = new DisplayGroup1();
      this.defineDataGroup = function(displayDelay, x, y, vw, bc, vc, lc) {  //no displayDelay in ArrivalsComponent
        this.displayDelay = displayDelay;
        this.dataGroup.define(this.componentID, this.componentType, x, y, vw, bc, vc, lc);
      };
      this.dataGroup.addValue(this.startBlockTime, "Start Time", "numdec", 5);
      this.dataGroup.addValue(this.currentBlockTime, "CurrentTime", "numdec", 5);
      this.dataGroup.addValue(this.endBlockTime, "End Time", "numdec", 5);
      this.dataGroup.addValue(this.entitiesScheduled, "# Entities", "integer");
      this.dataGroup.addValue(this.entitiesRemaining, "# Remaining", "integer");
      this.dataGroup.addValue(this.entryEntityID, "Entity ID", "integer");
      this.dataGroup.addValue(this.activity, "Activity", "text");

      this.assignDisplayValues = function() {
        this.dataGroup.valueList[0].value = this.startBlockTime;
        this.dataGroup.valueList[1].value = this.currentBlockTime;
        this.dataGroup.valueList[2].value = this.endBlockTime;
        this.dataGroup.valueList[3].value = this.entitiesScheduled;
        this.dataGroup.valueList[4].value = this.entitiesRemaining;
        this.dataGroup.valueList[5].value = this.entryEntityID;
        this.dataGroup.valueList[6].value = this.activity;
      };

      this.drawData = function() {
        this.assignDisplayValues();
        this.dataGroup.drawBasic();
      };
      //this.defineGraphic = function(graphic) {
      //  this.graphic = graphic;
      //};
      //this.updateGraphic = function() {
      //  //do nothing
      //};

      this.makeEntity = function() {  //ArrivalsComponent
        var e = generateNewEntity();   //var e = generateNewEntity(this);
        assignEntityTypes(e);
        recordGroupStatsSystemEntryWrapper("System",e);
        this.currentBlockTime = globalSimClock;
        this.entitiesRemaining--;
        this.entryEntityID = e.getEntityID();
        this.activity = "make entity";
        displayProgressText("Arrivals comp. " + this.componentID + " generates entity: " + this.entryEntityID + " at time " + globalSimClock.toFixed(6));
        //do something to send it to the entry component
        this.forwardEntity(e);
        //more to generate
        if (this.entitiesRemaining > 0) {
          var nextIndex = this.entitiesScheduled - this.entitiesRemaining;
          var nextTime = this.arrivalArray[nextIndex];
          var thisIndex = nextIndex - 1;
          var thisTime = this.arrivalArray[thisIndex];
          advance(nextTime - thisTime, this, "makeEntity");
        }
      };  //this.makeEntity
      this.blockIncrement = function() {  //should be called at the beginning of every time block
        //get arrival count per array index
        this.scheduleIndex++;  //starts from -1, updates at beginning of each window so has same value through duration of window
        this.entitiesScheduled = scheduleArray[this.scheduleIndex];
        if (this.entitiesScheduled > 0) {
          this.arrivalArray = [];
          for (var i = 0; i < this.entitiesScheduled; i++) {
            this.arrivalArray[i] = Math.random() * scheduleBlockMinutes;
          }
          //sort the array
          this.arrivalArray.sort(compareNumeric);
          //jump(globalSimClock+this.arrivalArray[0],this,"makeEntity");  //assume all components created at time zero
          advance(this.arrivalArray[0], this, "makeEntity");  //assume all components created at time zero
        }
        displayProgressText("Arrivals comp. " + this.componentID + " generates " + this.entitiesScheduled + " new entities at time " + globalSimClock.toFixed(6));
        //set values for display-------------
        this.startBlockTime = globalSimClock;
        this.currentBlockTime = globalSimClock;
        this.endBlockTime = globalSimClock + this.incrementTime;
        this.entitiesRemaining = this.entitiesScheduled;
        this.entryEntityID = "";
        this.activity = "generate";
        //----------------------------------
        if (globalSimClock + this.incrementTime >= this.endTime) {
          advance(this.incrementTime, this, "destroy");
        } else {
          advance(this.incrementTime, this, "increment");
        }
      };  //this.blockIncrement
      this.destroy = function() {
        displayProgressText("Arrivals comp. " + this.componentID + " terminates at time " + globalSimClock.toFixed(6));
      };  //this.destroy

      this.forwardEntity = function(entity) {  //ArrivalsCompponent
        //add test to ensure nextComponent is actually assigned
        //TODO-: should be done in verification after network defined and initialized
        var dest = 0;
        var test = Math.random();
        while (test > entryDistributionArray[this.scheduleIndex][dest]) {
          dest++;
        }
        if (dest > this.nextComponentCount) {
          alert("Arrival comp. tried to assign to entry with too high of an index");
        }
        displayProgressText("Arrivals comp. " + this.componentID + " test: " + test.toFixed(4) + " vs. " + entryDistributionArray[this.scheduleIndex][dest]);
        this.nextComponentList[dest].receiveEntity(entity);
      };
      this.activate = function(nextState) {
        if (nextState == "makeEntity") {
          this.makeEntity();
        } else if (nextState == "increment") {
          this.blockIncrement();
        } else if (nextState == "destroy") {
          this.destroy();
        } else {
          errorUndefinedAdvanceState(this.entityID, nextState);
        }
      };
    }  //ArrivalsComponent

    dummy1 = 1;
    
    //##default parameters##
    //function EntryComponent(displayDelay, routingTable = [1.0]) {  
    //function EntryComponent(displayDelay) {
      //var routingTable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [1.0];
    function EntryComponent(routingTable) {
      if (typeof routingTable === "undefined") {routingTable = [1.0];}
      //must be non-exclusive
      setOfComponents.push(this);
      this.componentID = getNewComponentID();
      this.componentType = "Entry";
      this.componentName = "Entry";
      this.componentGroup = "Entry";
      this.exclusive = false;
      this.routingMethod = 1;  //1: one connection, 2: distribution, 3: routing
      this.nextComponentList = [];
      this.nextComponentCount = 0;
      this.nextComponentIndex = 0;
      this.maxCapacity = Infinity;
      this.routingTable = routingTable;
      //this.savedDestination = -1;  //not needed for Entry component, must *always* be able to forward entities
      this.openStatus = true;
      this.entryTime = "";
      this.entryEntityID = "";
      this.activity = "";
      this.entryCount = 0;
      this.endEntryDisplayTime = 0;
      this.displayDelay = 0;
      this.graphic = null;

      this.reset = function() {
        this.nextComponentIndex = this.nextComponentCount - 1;
        //this.savedDestination = -1;
        this.openStatus = true;
        this.entryTime = "";
        this.entryEntityID = "";
        this.activity = "";
        this.entryCount = 0;
        this.endEntryDisplayTime = 0;
      };
      this.assignNextComponent = function(next) {  //EntryComponent
        this.nextComponentList.push(next);
        this.nextComponentCount++;
        this.nextComponentIndex = this.nextComponentCount - 1;
        next.assignPreviousComponent(this);
      };
/*      this.verifyLinks = function() {
        var error = "";
        if (this.nextComponentCount > 0) {
          for (var i = 0; i < this.nextComponentCount; i++) {  //>
            if (this.nextComponentList[i]) {  //link exists
              if (typeof this.nextComponentList[i] === "object") {  //link points to an object
                if ("componentType" in this.nextComponentList[i]) {  //object contains member componentType
                  if ((this.nextComponentList[i].componentType == "Arrivals") ||
                      (this.nextComponentList[i].componentType == "Entry") ||
                      (this.nextComponentList[i].componentType == "Exit")) {
                    error += this.componentType + " comp. " + this.componentID + " next comp. list element " + i + " is not an allowed comp.\n";
                  }
                } else {
                  //linked object does not contain member componentType
                  error += this.componentType + " comp. " + this.componentID + " next comp. list item " + i + " does not have componentType\n";
                }
              } else {
                //link points to something that is not an object
                error += this.componentType + " comp. " + this.componentID + " next comp. list item " + i + " is not an object\n";
              }
            } else {
              //link that should exist does not
              error += this.componentType + " comp. " + this.componentID + " next comp. list item " + i + " does not exist\n";
            }
          }
        } else {
          error += this.componentType + " comp. " + this.componentID + " has index of zero next components\n";
        }
        return error;
      };  */
/*      this.verifyNextNotExclusive = function() {
        var error = "";
        for (var i = 0; i < this.nextComponentCount; i++) {
          if (this.nextComponentList[i].getExclusive()) {
            error += this.componentType + " comp. " + this.componentID + ", next comp. " + i + " should not be exclusive\n";
          }
        }
        return error;
      };  */

      this.getComponentID = function() {
        return this.componentID;
      };
      this.getComponentType = function() {  //EntryComponent
        return this.componentType;
      };
      this.getComponentName = function() {
        return this.componentName;
      };
      this.setComponentName = function(componentName) {
        this.componentName = componentName;
      };
      this.getComponentGroup = function() {
        return this.componentGroup;
      };
      this.setComponentGroup = function(componentGroup) {
        this.componentGroup = componentGroup;
        addToGroupStatsNameListWrapper(componentGroup);
      };
      this.getExclusive = function() {
        return this.exclusive;
      };
      //this.setExclusive = function(exclusive) {
      //  this.exclusive = exclusive;
      //};
      this.getOpenStatus = function() {
        return this.openStatus;
      };
      this.setOpenStatus = function(openStatus) {
        this.openStatus = openStatus;
      };
      this.getRoutingMethod = function() {
        return this.routingMethod;
      };
      this.setRoutingMethod = function(routingMethod) {
        this.routingMethod = routingMethod;
      };
      this.getEntryTime = function() {
        return this.entryTime;
      };
      this.getEntryEntityID = function() {
        return this.entryEntityID;
      };
      this.getActivity = function() {
        return this.activity;
      };
      this.getEntryCount = function() {
        return this.entryCount;
      };
      this.getEndEntryDisplayTime = function() {
        return this.endEntryDisplayTime;
      };

      this.dataGroup = new DisplayGroup1();
      
      this.initDataGroup = function() {
        this.dataGroup.addValue(this.entryTime, "Entry Time", "numdec", 5);
        this.dataGroup.addValue(this.entryEntityID, "Entity ID", "integer");
        this.dataGroup.addValue(this.activity, "Activity", "text");
        this.dataGroup.addValue(this.nextComponentIndex, "Next Comp.", "integer");
        this.dataGroup.addValue(this.entryCount, "Entry Count", "text");
      };
      this.defineDataGroup = function(displayDelay, x, y, vw, bc, vc, lc) {
        this.displayDelay = displayDelay;
        this.dataGroup.define(this.componentID, this.componentType, x, y, vw, bc, vc, lc);
        this.initDataGroup();
      };      
      this.assignDisplayValues = function() {
        this.dataGroup.valueList[0].value = this.entryTime;
        this.dataGroup.valueList[1].value = this.entryEntityID;
        this.dataGroup.valueList[2].value = this.activity;
        this.dataGroup.valueList[3].value = this.nextComponentIndex;
        this.dataGroup.valueList[4].value = this.entryCount;
      };
      this.drawData = function() {
        this.assignDisplayValues();
        this.dataGroup.drawBasic();
      };

      this.defineGraphic = function(graphic) {
        this.graphic = graphic;
      };
      this.updateGraphic = function() {
        //do nothing
      };

      this.isOpen = function() {  //EntryComponent
        return this.openStatus;  //always receives entities (from ArrivalsComponent)
      };
      this.clearEntryDisplay = function() {
        //only clear display if a new one hasn't started a new timer
        if (globalSimClock >= this.endEntryDisplayTime) {
          this.entryTime = "";
          this.entryEntityID = "";
          this.activity = "";
        }
        //displayProgressText("Entry comp. "+this.componentID+" clears at time "+globalSimClock.toFixed(6));
      };
      this.nextOpen = function() {
        var startIndex = this.nextComponentIndex;
        var tempIndex = startIndex;
        do {
          tempIndex++;
          if (tempIndex >= this.nextComponentCount) {
            tempIndex = 0;
          }
          if (this.nextComponentList[tempIndex].isOpen()) {
            //open link found, update and return nextComponentIndex
            //this.nextComponentIndex = tempIndex;
            return tempIndex;
          }
        } while (tempIndex != startIndex);
        return -1;  //no open links found, leave nextComponentIndex unchanged
      };
      this.forwardEntity = function(entity) {  //EntryComponent
        var dest = -1;
        if (this.routingMethod == 1) {         //single connection
          if (this.nextComponentList[0].isOpen()) {
            dest = 0;
          }
        } else if (this.routingMethod == 2) {  //distribution
          var nextIndex = this.nextOpen();
          if (nextIndex >= 0) {
            dest = nextIndex;
            //this.nextComponentIndex = dest;
          }
        } else if (this.routingMethod == 3) {  //model routing logic
          //if (this.savedDestination >= 0) {
          //  dest = this.savedDestination;
          //} else {
          dest = 0;
          var test = Math.random();
          //need access to entity type but can't pop it off queue here
          var index = this.countInQueue - 1;
          if (index >= 0) {
            index = entityDiversionPercentIndex(this.entityQueue[index]);  //get head item in queue and find out what type it is
          } else {
            index = 0;  //nothing in queue, following code will work but nothing will be popped and processed below
          }
          while (test > this.routingTable[index][dest]) {
            dest++;
          }
          if (dest <= this.nextComponentCount) {
            if (!this.nextComponentList[dest].isOpen()) {
              dest = -1;
            }
          } else {
            alert("Entry comp. tried to assign destination with too high of an index")
          }
          //}
          //if (dest >= 0) {
          //  this.savedDestination = dest;
          //}
        } else {  //0 uninitialized or anything else
          alert("comp. " + this.componentID + " incorrect routing method: " + this.routingMethod);
        }
        if (dest >= 0) {
          this.nextComponentIndex = dest;
          //this.savedDestination = -1;
          this.nextComponentList[dest].receiveEntity(entity);  //TODO-: pre-verify that next component is guaranteed to accept an entity
        }
      };
      this.receiveEntity = function(entity) {  //EntryComponent
        //display what's going to happen
        this.entryTime = globalSimClock;
        this.entryEntityID = entity.entityID;
        this.activity = "receive entity";
        //entity.entryTime = globalSimClock;  not needed since set on creation in ArrivalsComponent
        displayProgressText("Entry comp. " + this.componentID + " injects entity: " + entity.entityID + " at time " + globalSimClock.toFixed(6));
        //set timer to clear the display after a bit
        this.endEntryDisplayTime = globalSimClock + this.displayDelay;
        this.entryCount++;
        advance(this.displayDelay, this, "clearEntryDisplay");
        //send it someplace
        this.forwardEntity(entity);
      };
      this.activate = function(nextState) {
        if (nextState == "clearEntryDisplay") {
          this.clearEntryDisplay();
        } else {
          errorUndefinedAdvanceState(this.entityID, this.nextState);
        }
      };  //this.activate
    }  //EntryComponent
    EntryComponent.prototype.verifyLinks = function() {
      var error = "";
      if (this.nextComponentCount > 0) {
        for (var i = 0; i < this.nextComponentCount; i++) {  //>
          if (this.nextComponentList[i]) {  //link exists
            if (typeof this.nextComponentList[i] === "object") {  //link points to an object
              if ("componentType" in this.nextComponentList[i]) {  //object contains member componentType
                if ((this.nextComponentList[i].componentType == "Arrivals") ||
                    (this.nextComponentList[i].componentType == "Entry") ||
                    (this.nextComponentList[i].componentType == "Exit")) {
                  error += this.componentType + " comp. " + this.componentID + " next comp. list element " + i + " is not an allowed comp.\n";
                }
              } else {
                //linked object does not contain member componentType
                error += this.componentType + " comp. " + this.componentID + " next comp. list item " + i + " does not have componentType\n";
              }
            } else {
              //link points to something that is not an object
              error += this.componentType + " comp. " + this.componentID + " next comp. list item " + i + " is not an object\n";
            }
          } else {
            //link that should exist does not
            error += this.componentType + " comp. " + this.componentID + " next comp. list item " + i + " does not exist\n";
          }
        }
      } else {
        error += this.componentType + " comp. " + this.componentID + " has index of zero next components\n";
      }
      return error;
    };
    EntryComponent.prototype.verifyNextNotExclusive = function() {
      var error = "";
      for (var i = 0; i < this.nextComponentCount; i++) {
        if (this.nextComponentList[i].getExclusive()) {
          error += this.componentType + " comp. " + this.componentID + ", next comp. " + i + " should not be exclusive\n";
        }
      }
      return error;
    };

    function StartSubJourneyComponent(parent) {
      setOfComponents.push(this);
      this.componentID = getNewComponentID();
      this.componentType = "startSubJourney";
      this.componentName = "startSubJourney";
      this.nextComponent = null;
      this.parent = parent;
      this.exclusive = false;
      this.graphic = null;
      this.x1 = 0;
      this.y1 = 0;
      this.reset = function() {
        //do nothing
      };
      this.assignNextComponent = function(next) {  //StartSubJourneyComponent
        this.nextComponent = next;
        next.assignPreviousComponent(this);
      };
      this.verifyLinks = function() {
        var error = "";
        if (this.nextComponent) {  //link exists
          if (typeof this.nextComponent === "object") {  //link points to an object
            if ("componentType" in this.nextComponent) {  //object contains member componentType
              if ((this.nextComponent.componentType == "Arrivals") ||
                  (this.nextComponent.componentType == "Entry")) {
                error += this.componentType + " comp. " + this.componentID + " next comp. is not an allowed comp.\n";
              }
            } else {
              //linked object does not contain member componentType
              error += this.componentType + " comp. " + this.componentID + " next comp. does not have componentType\n";
            }
          } else {
            //link points to something that is not an object
            error += this.componentType + " comp. " + this.componentID + " next comp. is not an object\n";
          }
        } else {
          //link that should exist does not
          error += this.componentType + " comp. " + this.componentID + " next comp. does not exist\n";
        }
/*        if (this.previousComponent) {  //link exists
          if (typeof this.previousComponent === "object") {  //link points to an object
            if ("componentType" in this.previousComponent) {  //object contains member componentType
              if ((this.previousComponent.componentType == "Arrivals") ||
                  (this.previousComponent.componentType == "Exit")) {
                error += this.componentType + " comp. " + this.componentID + " previous comp. is not an allowed comp.\n";
              }
            } else {
              //linked object does not contain member componentType
              error += this.componentType + " comp. " + this.componentID + " previous comp. does not have componentType\n";
            }
          } else {
            //link points to something that is not an object
            error += this.componentType + " comp. " + this.componentID + " previous comp. is not an object\n";
          }
        } else {
          //link that should exist does not
          error += this.componentType + " comp. " + this.componentID + " previous comp. does not exist\n";
        }  */
        return error;
      };

      this.getComponentID = function() {
        return this.componentID;
      };
      this.getComponentType = function() {
        return this.componentType;
      };
      this.getComponentName = function() {
        return this.componentName;
      };
      this.setComponentName = function(componentName) {
        this.componentName = componentName;
      };
      this.getExclusive = function() {
        return this.exclusive;
      };
      this.defineGraphic = function(graphic) {
        this.graphic = graphic;  //TODO: ensure location automatically set by return node in parent component
      };
      this.updateGraphic = function() {
      };
      this.assignLocation = function(x,y) {
        this.x1 = x;
        this.y1 = y;
      };
      this.getLocation = function() {
        return {x: this.x1, y: this.y1};
      };
      this.receiveEntity = function(entity) {
        this.nextComponent.receiveEntity(entity);
      };
    }  //StartSubJourneyComponent

    function ReturnFromSubJourneyComponent(parent) {
      setOfComponents.push(this);
      this.componentID = getNewComponentID();
      this.componentType = "returnFromSubJourney";  //TODO: see if this should return the type of the parent component instead
      this.componentName = "returnFromSubJourney";  //TODO: see if this should return the name of the parent component instead
      this.parent = parent;
      this.exclusive = false;
      this.openStatus = true;
      this.previousComponentList = [];
      this.previousComponentCount = 0;
      this.previousComponentIndex = 0;
      this.graphic = null;
      this.x1 = 0;
      this.y1 = 0;
      this.reset = function() {
        //do nothing
      };
      
      this.assignPreviousComponent = function(prev) {
        this.previousComponentList.push(prev);
        this.previousComponentCount++;
        this.previousComponentIndex = this.previousComponentCount - 1;
      };
      this.verifyLinks = function() {
        var error = "";
        var i;
/*        if (this.nextComponent) {  //link exists
          if (typeof this.nextComponent === "object") {  //link points to an object
            if ("componentType" in this.nextComponent) {  //object contains member componentType
              if ((this.nextComponent.componentType == "Arrivals") ||
                  (this.nextComponent.componentType == "Entry")) {
                error += this.componentType + " comp. " + this.componentID + " next comp. is not an allowed comp.\n";
              }
            } else {
              //linked object does not contain member componentType
              error += this.componentType + " comp. " + this.componentID + " next comp. does not have componentType\n";
            }
          } else {
            //link points to something that is not an object
            error += this.componentType + " comp. " + this.componentID + " next comp. is not an object\n";
          }
        } else {
          //link that should exist does not
          error += this.componentType + " comp. " + this.componentID + " next comp. does not exist\n";
        }  */
        if (this.previousComponentCount > 0) {
          for (i = 0; i < this.previousComponentCount; i++) {  //>
            if (this.previousComponentList[i]) {  //link exists
              if (typeof this.previousComponentList[i] === "object") {  //link points to an object
                if ("componentType" in this.previousComponentList[i]) {  //object contains member componentType
                  if ((this.previousComponentList[i].componentType == "Arrivals") ||
                      (this.previousComponentList[i].componentType == "Exit")) {
                    error += this.componentType + " comp. " + this.componentID + " previous comp. list element " + i + " is not an allowed comp.\n";
                  }
                } else {
                  //linked object does not contain member componentType
                  error += this.componentType + " comp. " + this.componentID + " previous comp. list item " + i + " does not have componentType\n";
                }
              } else {
                //link points to something that is not an object
                error += this.componentType + " comp. " + this.componentID + " previous comp. list item " + i + " is not an object\n";
              }
            } else {
              //link that should exist does not
              error += this.componentType + " comp. " + this.componentID + " previous comp. list item " + i + " does not exist\n";
            }
          }
        } else {
          error += this.componentType + " comp. " + this.componentID + " has index of zero previous components\n";
        }
        return error;
      };

      this.getComponentID = function() {
        return this.componentID;
      };
      this.getComponentType = function() {
        return this.componentType;
      };
      this.getComponentName = function() {
        return this.componentName;
      };
      this.setComponentName = function(componentName) {
        this.componentName = componentName;
      };
      this.getComponentGroup = function() {
        return this.parent.getComponentGroup();
      };
      this.getExclusive = function() {
        return this.exclusive;
      };
      this.isOpen = function() {
        return this.openStatus;
      };
      this.defineGraphic = function(graphic) {
        this.graphic = graphic;  //TODO: ensure location automatically set by return node in parent component
      };
      this.updateGraphic = function() {
      };
      this.assignLocation = function(x,y) {
        this.x1 = x;
        this.y1 = y;
      };
      this.getLocation = function() {
        return {x: this.x1, y: this.y1};
      };
      this.receiveEntity = function(entity) {
        this.parent.returnFromSubJourney(entity);
      };
    }  //ReturnFromSubJourneyComponent
    
    //##default parameters##
    //function QueueComponent(displayDelay, traversalTime, maxCapacity = Infinity, routingTable = [1.0]) {
    //function QueueComponent(displayDelay, traversalTime) {
      //var maxCapacity = arguments.length > 1 && arguments[2] !== undefined ? arguments[2] : Infinity;
      //var routingTable = arguments.length > 2 && arguments[3] !== undefined ? arguments[3] : [1.0];
    function QueueComponent(traversalTime, maxCapacity, routingTable) {
      if (typeof maxCapacity === "undefined") {maxCapacity = Infinity;}
      if (typeof routingTable === "undefined") {routingTable = [1.0];}
      setOfComponents.push(this);
      this.componentID = getNewComponentID();
      this.componentType = "Queue";
      this.componentName = "Queue";
      this.componentGroup = "Queue";
      this.routingMethod = 2;  //1: one connection, 2: distribution, 3 routing
      this.previousComponentList = [];
      this.previousComponentCount = 0;
      this.nextComponentList = [];
      this.nextComponentCount = 0;
      this.nextComponentIDList = [];
      this.traversalTime = traversalTime;
      this.maxCapacity = maxCapacity;  //negative or very large means infinite capacity and non-exclusive by default)
      if (this.maxCapacity < Infinity) {
        this.exclusive = true;
      } else {
        this.exclusive = false;
      }
      this.savedDestination = -1;
      this.previousComponentIndex = 0;
      this.nextComponentIndex = 0;
      this.entityQueue = [];
      this.routingTable = routingTable;
      this.openStatus = true;
      this.entryTime = "";
      this.entryEntityID = "";
      this.exitTime = "";
      this.exitEntityID = "";
      this.exitResidenceTime = "";
      this.countInQueue = 0;
      this.countInTraversal = 0;
      this.activity = "";
      this.endEntryDisplayTime = 0;
      this.endExitDisplayTime = 0;
      this.endAllDisplayTime = 0;
      this.displayDelay = 0;
      //this.nextTraverseCompleteTime = 0.0;  //TODO: eliminate this when related TODOs addressed
      this.graphic = null;

      this.reset = function() {
        this.previousComponentIndex = this.previousComponentCount - 1;
        this.nextComponentIndex = this.nextComponentCount - 1;
        this.savedDestination = -1;
        this.entityQueue = [];
        this.openStatus = true;
        //this.forwardAttemptTime = Infinity;
        this.entryTime = "";
        this.entryEntityID = "";
        this.exitTime = "";
        this.exitEntityID = "";
        this.exitResidenceTime = "";
        this.countInQueue = 0;
        this.countInTraversal = 0;
        this.activity = "";
        this.endEntryDisplayTime = 0;
        this.endExitDisplayTime = 0;
        this.endAllDisplayTime = 0;
      };
      this.assignPreviousComponent = function(prev) {
        this.previousComponentList.push(prev);
        this.previousComponentCount++;
        this.previousComponentIndex = this.previousComponentCount - 1;
      };
      this.assignNextComponent = function(next) {  //QueueComponent
        this.nextComponentList.push(next);
        this.nextComponentCount++;
        this.nextComponentIndex = this.nextComponentCount - 1;
        next.assignPreviousComponent(this);
      };
      this.getNextComponentIDs = function() {
        for (var i = 0; i < this.nextComponentCount; i++) {
          if (this.nextComponentList[i].getComponentType() != "Path") {
            this.nextComponentIDList[i] = this.nextComponentList[i].getComponentID();
          } else {
            this.nextComponentIDList[i] = this.nextComponentList[i].passComponentID();
          }
        }
      };
      this.verifyLinks = function() {
        var i;
        var error = "";
        if (this.nextComponentCount > 0) {
          for (i = 0; i < this.nextComponentCount; i++) {  //>
            if (this.nextComponentList[i]) {  //link exists
              if (typeof this.nextComponentList[i] === "object") {  //link points to an object
                if ("componentType" in this.nextComponentList[i]) {  //object contains member componentType
                  if ((this.nextComponentList[i].componentType == "Arrivals") ||
                      (this.nextComponentList[i].componentType == "Entry")) {
                    error += this.componentType + " comp. " + this.componentID + " next comp. list element " + i + " is not an allowed comp.\n";
                  }
                } else {
                  //linked object does not contain member componentType
                  error += this.componentType + " comp. " + this.componentID + " next comp. list item " + i + " does not have componentType\n";
                }
              } else {
                //link points to something that is not an object
                error += this.componentType + " comp. " + this.componentID + " next comp. list item " + i + " is not an object\n";
              }
            } else {
              //link that should exist does not
              error += this.componentType + " comp. " + this.componentID + " next comp. list item " + i + " does not exist\n";
            }
          }
        } else {
          error += this.componentType + " comp. " + this.componentID + " has index of zero next components\n";
        }
        if (this.previousComponentCount > 0) {
          for (i = 0; i < this.previousComponentCount; i++) {  //>
            if (this.previousComponentList[i]) {  //link exists
              if (typeof this.previousComponentList[i] === "object") {  //link points to an object
                if ("componentType" in this.previousComponentList[i]) {  //object contains member componentType
                  if ((this.previousComponentList[i].componentType == "Arrivals") ||
                      (this.previousComponentList[i].componentType == "Exit")) {
                    error += this.componentType + " comp. " + this.componentID + " previous comp. list element " + i + " is not an allowed comp.\n";
                  }
                } else {
                  //linked object does not contain member componentType
                  error += this.componentType + " comp. " + this.componentID + " previous comp. list item " + i + " does not have componentType\n";
                }
              } else {
                //link points to something that is not an object
                error += this.componentType + " comp. " + this.componentID + " previous comp. list item " + i + " is not an object\n";
              }
            } else {
              //link that should exist does not
              error += this.componentType + " comp. " + this.componentID + " previous comp. list item " + i + " does not exist\n";
            }
          }
        } else {
          error += this.componentType + " comp. " + this.componentID + " has index of zero previous components\n";
        }
        return error;
      };

      this.getComponentID = function() {
        return this.componentID;
      };
      this.getComponentType = function() {  //QueueComponent
        return this.componentType;
      };
      this.getComponentName = function() {
        return this.componentName;
      };
      this.setComponentName = function(componentName) {
        this.componentName = componentName;
      };
      this.getComponentGroup = function() {
        return this.componentGroup;
      };
      this.setComponentGroup = function(componentGroup) {
        this.componentGroup = componentGroup;
        addToGroupStatsNameListWrapper(componentGroup);
      };
      this.getExclusive = function() {
        return this.exclusive;
      };
      //this.setExclusive = function(exclusive) {
      //  this.exclusive = exclusive;
      //};
      this.getTraversalTime = function() {
        return this.traversalTime;
      };
      this.getMaxCapacity = function() {
        return this.maxCapacity;
      };
      this.setMaxCapacity = function(maxCapacity) {
        this.maxCapacity = maxCapacity;
      };
      this.getOpenStatus = function() {
        return this.openStatus;
      };
      this.setOpenStatus = function(openStatus) {
        this.openStatus = openStatus;
      };
      this.getForwardAttemptTime = function() {
        if (this.countInQueue > 0) {
          return this.entityQueue[this.countInQueue - 1].getForwardAttemptTime();
        } else {
          return Infinity;
        }
      };
      this.getRoutingMethod = function() {
        return this.routingMethod;
      };
      this.setRoutingMethod = function(routingMethod) {
        this.routingMethod = routingMethod;
      };
      this.getEntryTime = function() {
        return this.entryTime;
      };
      this.getEntryEntityID = function() {
        return this.entryEntityID;
      };
      this.getExitTime = function() {
        return this.exitTime;
      };
      this.getExitEntityID = function() {
        return this.exitEntityID;
      };
      this.getExitResidenceTime = function() {
        return this.exitResidenceTime;
      };
      this.getCountInQueue = function() {
        return this.countInQueue;
      };
      this.getCountInTraversal = function() {
        return this.countInTraversal;
      };
      this.getActivity = function() {
        return this.activity;
      };
      this.getEndEntryDisplayTime = function() {
        return this.endEntryDisplayTime;
      };
      this.getEndExitDisplayTime = function() {
        return this.endExitDisplayTime;
      };
      this.getEndAllDisplayTime = function() {
        return this.endAllDisplayTime;
      };

      this.dataGroup = new DisplayGroup1();
      this.defineDataGroup = function(displayDelay, x, y, vw, bc, vc, lc) {
        this.displayDelay = displayDelay;
        this.dataGroup.define(this.componentID, this.componentType, x, y, vw, bc, vc, lc);
      };
      this.dataGroup.addValue(this.entryEntityID, "Entry ID", "integer");
      this.dataGroup.addValue(this.countInQueue, "# In Queue", "integer");
      this.dataGroup.addValue(this.countInTraversal, "# Traversing", "integer");
      this.dataGroup.addValue(this.maxCapacity, "Capacity", "integer");
      this.dataGroup.addValue(this.exitEntityID, "Exit ID", "integer");
      //this.dataGroup.addValue(this.exitResidenceTime,"Resdnce Tm","numdec",5);
      this.dataGroup.addValue(this.nextComponentIndex, "Next comp.", "integer");
      this.dataGroup.addValue(this.activity, "Activity", "text");
      this.dataGroup.addValue(this.getForwardAttemptTime(), "Fwd Attmpt", "numdec", 5);

      this.assignDisplayValues = function() {
        this.dataGroup.valueList[0].value = this.entryEntityID;
        this.dataGroup.valueList[1].value = this.countInQueue;
        this.dataGroup.valueList[2].value = this.countInTraversal;
        this.dataGroup.valueList[3].value = this.maxCapacity;
        this.dataGroup.valueList[4].value = this.exitEntityID;
        //this.dataGroup.valueList[5].value = this.exitResidenceTime;
        this.dataGroup.valueList[5].value = this.nextComponentIndex;
        this.dataGroup.valueList[6].value = this.activity;
        this.dataGroup.valueList[7].value = this.getForwardAttemptTime();
        if (this.exclusive) {
          if (this.openStatus) {
            this.dataGroup.setBorderColor("#00FF00");
          } else {
            this.dataGroup.setBorderColor("#FF0000");
          }
        }
      };

      this.drawData = function() {  //Queue component
        this.assignDisplayValues();
        this.dataGroup.drawBasic();
      };

      this.defineGraphic = function(graphic) {
        this.graphic = graphic;
      };
      this.updateGraphic = function() {
        this.graphic.setTraverseValue(this.countInTraversal);
        this.graphic.setCountValue(this.countInQueue);
      };

      this.isOpen = function() {  //QueueComponent
        if (this.exclusive) {
          if (this.currentCount() < this.maxCapacity) {
            this.openStatus = true;
          } else {
            this.openStatus = false;
          }
          for (var i = 0; i < this.previousComponentCount; i++) {
            if (this.previousComponentList[i].getComponentType() == "Path") {
              this.previousComponentList[i].setPreviousStatus(this.openStatus);  //this may only be needed to determine open/closed status for display, count <=> capacity used when something is trying to enter
            }
          }
        }
        return this.openStatus;  //if not exclusive should be set to true by default
      };
      this.clearEntryDisplay = function() {
        //only clear display if a new one hasn't started a new timer
        if (globalSimClock >= this.endEntryDisplayTime) {
          this.entryTime = "";
          this.entryEntityID = "";
        }
        if (globalSimClock >= this.endAllDisplayTime) {
          this.activity = "";
        }
        //displayProgressText("Queue entry "+this.componentID+" clears at time "+globalSimClock.toFixed(6));
      };
      this.clearExitDisplay = function() {
        //only clear display if a new one hasn't started a new timer
        if (globalSimClock >= this.endExitDisplayTime) {
          this.exitTime = "";
          this.exitEntityID = "";
          this.exitResidenceTime = "";
        }
        if (globalSimClock >= this.endAllDisplayTime) {
          this.activity = "";
        }
        //displayProgressText("Queue exit "+this.componentID+" clears at time "+globalSimClock.toFixed(6));
      };
      this.currentCount = function() {
        var count = 0;
        if (this.exclusive) {
          //start with entities already in component
          count = this.countInQueue;
          //add entities in feeding paths
          for (var i = 0; i < this.previousComponentCount; i++) {
            if (this.previousComponentList[i].componentType == "Path") {  //TODO: consider adding test for whether path is boundary component for associated exclusive group of components -- done this by inserting no-time/no-space control components
              count += this.previousComponentList[i].currentCount();
            }
          }
        }
        return count;
      };
      this.pullFromPrevious = function() {  //QueueComponent
        var oldest = this.previousComponentList[0].getForwardAttemptTime();
        var oldestIndex = 0;
        for (var i = 1; i < this.previousComponentCount; i++) {
          var age = this.previousComponentList[i].getForwardAttemptTime();
          if (age < oldest) {
            oldestIndex = i;
          }
        }
        if (this.previousComponentList[oldestIndex].getComponentType() != "Path") {
          if (this.previousComponentList[oldestIndex].getComponentType() != "Entry") {
            //TODO: this should call forward entity in a way that ensures that previous component only sends entity to where it is requested and if one is available and if this is a legitimate destination
            this.previousComponentList[oldestIndex].forwardEntity(this.componentID);
          }
        } else {
          displayProgressText("Queue comp. " + this.componentID + " pulls from previous at time " + globalSimClock.toFixed(6));
          this.previousComponentList[oldestIndex].pullFromPrevious(this.componentID);
        }
      };
      this.nextOpen = function() {
        var startIndex = this.nextComponentIndex;
        var tempIndex = startIndex;
        do {
          tempIndex++;
          if (tempIndex >= this.nextComponentCount) {
            tempIndex = 0;
          }
          if (this.nextComponentList[tempIndex].isOpen()) {
            //open link found, update and return nextComponentIndex
            return tempIndex;
          }
        } while (tempIndex != startIndex);
        return -1;  //no open links found, leave nextComponentIndex unchanged
      };
      this.traverseComplete = function() {
        this.countInTraversal--;   //TODO: ensure handled properly if traversal time is zero
        //figure out which entity just finished traversing
        var tempID = this.entityQueue[this.countInTraversal].entityID;  //TODO: this works for FIFO, but not necessarily for other logics
        this.entityQueue[this.countInTraversal].setForwardAttemptTime(globalSimClock);
        displayProgressText("Queue comp. " + this.componentID + " entity: " + tempID + " trav. at time " + globalSimClock.toFixed(6));
        if (this.countInQueue - this.countInTraversal == 1) {  //don't bother trying to forward unless this is the lead item in the queue
          this.forwardEntity();
        }
      };
      //##default parameters##
      //this.forwardEntity = function(destIndex = -1) {  //QueueComponent
      //this.forwardEntity = function() {  //QueueComponent
        ///var routingTable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
      this.forwardEntity = function(destIndex) {  //QueueComponent
        if (typeof destIndex === "undefined") {destIndex = -1;}
        var dest = -1;
        if (destIndex >= 0) {  //pull request from a specific downstream component, must send entity there
          if (this.routingMethod == 1) { //single connection, nothing to do
            dest = 0;
          } else if (this.routingMethod == 2) { //distribution, send to any request
            dest = 0;
            while ((this.nextComponentIDList[dest] != destIndex) && (dest < this.nextComponentCount)) {  //second test should not be needed, loop can't fail to return valid result
              dest++;
            }
          } else if (this.routingMethod == 3) {  //model routing logic, TODO: don't forward if not desired destination
            dest = 0;
            while ((this.nextComponentIDList[dest] != destIndex) && (dest < this.nextComponentCount)) {  //second test should not be needed, loop can't fail to return valid result
              dest++;
            }
          }
          dummy2 = 0;
        } else {
          if (this.routingMethod == 1) {  //single connection
            if (this.nextComponentList[0].isOpen()) {
              dest = 0;
            }
          } else if (this.routingMethod == 2) {  //distribution
            var nextIndex = this.nextOpen();
            if (nextIndex >= 0) {
              dest = nextIndex;
              //this.nextComponentIndex = dest;
            }
          } else if (this.routingMethod == 3) {  //model routing logic
            if (this.savedDestination >= 0) {
              dest = this.savedDestination;
            } else {
              dest = 0;
              var test = Math.random();
              //need access to entity type but can't pop it off queue here
              var index = this.countInQueue - 1;
              if (index >= 0) {
                index = entityDiversionPercentIndex(this.entityQueue[index]);  //get head item in queue and find out what type it is
              } else {
                index = 0;  //nothing in queue, following code will work but nothing will be popped and processed below
              }
              while (test > this.routingTable[index][dest]) {
                dest++;
              }
              if (dest <= this.nextComponentCount) {
                if (!this.nextComponentList[dest].isOpen()) {
                  dest = -1;  //this works only because destinations are unique (i.e., can't send to multiple parallel types/processes, must send to a single queue feeding them)
                }
              } else {
                alert("Queue comp. tried to assign destination with too high of an index")
              }
              if (dest >= 0) {
                this.savedDestination = dest;
              }
            }
          } else {  //0 uninitialized or anything else
            alert("comp. " + this.componentID + " incorrect routing method: " + this.routingMethod);
          }
        }
        if (dest >= 0) {
          if (this.countInQueue > this.countInTraversal) {
            var entity = this.entityQueue.pop();  //TODO-: are we testing to ensure the next entity is really available
            //calculate how long item was in queue
            this.exitResidenceTime = globalSimClock - entity.getLocalEntryTime();
            //now use this to calculate stats for the interval
            this.exitTime = globalSimClock;
            this.exitEntityID = entity.entityID;
            this.activity = "forward entity";
            this.endExitDisplayTime = globalSimClock + this.displayDelay;
            this.endAllDisplayTime = this.endExitDisplayTime;
            advance(this.displayDelay, this, "clearExitDisplay");
            displayProgressText("Queue comp. " + this.componentID + " forwards entity: " + this.exitEntityID + " at time " + globalSimClock.toFixed(6));

            this.countInQueue--;
            //should be open now
            if (this.exclusive) {
              displayProgressText("Process comp. " + this.componentID + " calls pull from previous at time " + globalSimClock.toFixed(6));
              if (!this.openStatus) {
                this.pullFromPrevious(); //TODO: call this with a modest (~1 sec) delay to account for reaction time? //may or may not successfully get an entity but should always be called
              }
            }
            this.isOpen();
            this.nextComponentIndex = dest;
            this.savedDestination = -1;
            this.nextComponentList[dest].receiveEntity(entity);
          }
        }
      };
      this.receiveEntity = function(entity) {  //QueueComponent
        //receive the entity
        entity.setLocalEntryTime();  //record time entity entered queue
        if (entity.getComponentGroup() != this.componentGroup) {
          entity.setComponentGroup(this.componentGroup);
          entity.setComponentGroupEntryTime(globalSimClock);
          recordGroupStatsSystemEntryWrapper(this.componentGroup,entity);
        }
        entity.setForwardAttemptTime(Infinity);
        entity.setPermission(false);  //entity has reached end of related components group, permission no longer matters
        this.entityQueue.unshift(entity);
        this.countInQueue++;
        this.countInTraversal++;   //TODO: ensure handled properly if traversal time is zero
        this.isOpen();
        //display what was done
        this.entryTime = globalSimClock;
        this.entryEntityID = entity.entityID;
        this.activity = "receive entity";
        //set timer to clear the display after a bit
        this.endEntryDisplayTime = globalSimClock + this.displayDelay;
        this.endAllDisplayTime = this.endEntryDisplayTime;
        advance(this.displayDelay, this, "clearEntryDisplay");
        displayProgressText("Queue comp. " + this.componentID + " receives entity: " + this.entryEntityID + " at time " + globalSimClock.toFixed(6));
        if (this.traversalTime > 0) {
          //set timer for the new entity to track its traversal time
          advance(this.traversalTime, this, "traverseComplete");  //TODO: don't bother if traversal time is zero, also insure countInTraversal is decremented (or not incremented) as needed
        } else if (this.traversalTime == 0.0) {
          this.traverseComplete();
        }
//        //if (this.nextComponent.isOpen()) {  //TODO: run this if traversal time is zero
//        //  this.forwardEntity();
//        //}
      };
      this.activate = function(nextState) {
        if (nextState == "clearEntryDisplay") {
          this.clearEntryDisplay();
        } else if (nextState == "clearExitDisplay") {
          this.clearExitDisplay();
        } else if (nextState == "traverseComplete") {
          this.traverseComplete();
        } else {
          errorUndefinedAdvanceState(this.entityID, this.nextState);
        }
      };  //this.activate
    }  //QueueComponent

    //function QueueComponent1(displayDelay) {
    function QueueComponent1() {
      setOfComponents.push(this);
      this.componentID = getNewComponentID();
      this.componentType = "Queue";
      this.componentName = "Queue";
      this.entryTime = "";
      this.entryEntityID = "";
      //this.endEntryDisplayTime = 0;
      this.countInQueue = 0;
      this.exitTime = "";
      this.exitEntityID = "";
      this.exitResidenceTime = "";
      //this.endExitDisplayTime = 0;
      //this.endAllDisplayTime = 0;
      //this.activity = "";
      //this.displayDelay = displayDelay;
      this.nextComponent = null;
      this.entityQueue = [];

      this.reset = function() {
        this.entryTime = "";
        this.entryEntityID = "";
        //this.endEntryDisplayTime = 0;
        this.countInQueue = 0;
        this.exitTime = "";
        this.exitEntityID = "";
        this.exitResidenceTime = "";
        //this.endExitDisplayTime = 0;
        //this.endAllDisplayTime = 0;
        //this.activity = "";
        //this.displayDelay = displayDelay;
        this.entityQueue = [];
      };

      this.getComponentID = function() {
        return this.componentID;
      };
      this.getComponentType = function() {
        return this.componentType;
      };
      this.setComponentName = function(componentName) {
        this.componentName = componentName;
      };
      this.getComponentName = function() {
        return this.componentName;
      };
      this.getEntryTime = function() {
        return this.entryTime;
      };
      this.getEntryEntityID = function() {
        return this.entryEntityID;
      };
      this.getExitTime = function() {
        return this.exitTime;
      };
      this.getExitEntityID = function() {
        return this.exitEntityID;
      };
      this.getCountInQueue = function() {
        return this.countInQueue;
      };
      this.getExitResidenceTime = function() {
        return this.exitResidenceTime;
      };

//      this.dataGroup = new DisplayGroup(this.componentType,175,79,80,"#00FFFF","#FF0000","#FFFF00");
      //this.dataGroup = new DisplayGroup1();
      //this.defineDataGroup = function(x,y,vw,bc,vc,lc) {
      //  this.dataGroup.define(this.componentType,x,y,vw,bc,vc,lc);
      //};
      //this.dataGroup.addValue(this.componentID,"Comp. ID","integer");
      //this.dataGroup.addValue(this.entryTime,"Entry Time","numdec",5);
      //this.dataGroup.addValue(this.entryEntityID,"Entry ID","integer");
      //this.dataGroup.addValue(this.countInQueue,"# In Queue","numdec","integer");
      //this.dataGroup.addValue(this.exitTime,"Exit Time","numdec",5);
      //this.dataGroup.addValue(this.exitEntityID,"Exit ID","integer");
      //this.dataGroup.addValue(this.exitResidenceTime,"Resdnce Tm","numdec",5);
      //this.dataGroup.addValue(this.activity,"Activity","text");

      //this.assignDisplayValues = function() {
      //  this.dataGroup.valueList[0].value = this.componentID;
      //  this.dataGroup.valueList[1].value = this.entryTime;
      //  this.dataGroup.valueList[2].value = this.entryEntityID;
      //  this.dataGroup.valueList[3].value = this.countInQueue;
      //  this.dataGroup.valueList[4].value = this.exitTime;
      //  this.dataGroup.valueList[5].value = this.exitEntityID;
      //  this.dataGroup.valueList[6].value = this.exitResidenceTime;
      //  this.dataGroup.valueList[7].value = this.activity;
      //};
      this.drawData = function() {
        //  this.assignDisplayValues();
        //  this.dataGroup.drawBasic();
      };
      //this.clearEntryDisplay = function() {
      //  //only clear display if a new one hasn't started a new timer
      //  if (globalSimClock >= this.endEntryDisplayTime) {
      //    this.entryTime = "";
      //    this.entryEntityID = "";
      //    //this.exitResidenceTime = "";
      //  }
      //  if (globalSimClock >= this.endAllDisplayTime) {
      //    this.activity= "";
      //  }
      //  displayProgressText("Queue entry "+this.componentID+" clears at time "+globalSimClock.toFixed(6));
      //};
      //this.clearExitDisplay = function() {
      //  //only clear display if a new one hasn't started a new timer
      //  if (globalSimClock >= this.endExitDisplayTime) {
      //    this.exitTime = "";
      //    this.exitEntityID = "";
      //    this.exitResidenceTime = "";
      //  }
      //  if (globalSimClock >= this.endAllDisplayTime) {
      //    this.activity= "";
      //  }
      //  displayProgressText("Queue exit "+this.componentID+" clears at time "+globalSimClock.toFixed(6));
      //};
      this.assignNextComponent = function(next) {
        this.nextComponent = next;
      };
      this.forwardEntity = function() {  //QueueComponent1
        if (this.nextComponent.isOpen()) {
          var entity = this.entityQueue.pop();
          if (entity) {
            this.countInQueue--;  //TODO: handle zero vs. nonzero traverse time as above
            this.exitTime = globalSimClock;
            this.exitEntityID = entity.entityID;
            //      this.activity = "forward entity";
            //      this.endExitDisplayTime = globalSimClock+this.displayDelay;
            //      this.endAllDisplayTime = this.endExitDisplayTime;
            //      feq.newItem(this.endExitDisplayTime,this,"clearExitDisplay");
            displayProgressText("Queue comp. " + this.componentID + " forwards entity: " + this.exitEntityID + " at time " + globalSimClock.toFixed(6));
            this.nextComponent.receiveEntity(entity);
          }
        }
      };
      this.receiveEntity = function(entity) {  //QueueComponent1
        //receive the entity
        entity.setLocalEntryTime();  //record time entity entered queue
        this.entityQueue.unshift(entity);
        this.countInQueue++;
        //display what was done
        this.entryTime = globalSimClock;
        this.entryEntityID = entity.entityID;
        //  this.activity = "receive entity";
        //set timer to clear the display after a bit
        //  this.endEntryDisplayTime = globalSimClock+this.displayDelay;
        //  this.endAllDisplayTime = this.endEntryDisplayTime;
        //  feq.newItem(this.endEntryDisplayTime,this,"clearEntryDisplay");
        displayProgressText("Queue comp. " + this.componentID + " receives entity: " + this.entryEntityID + " at time " + globalSimClock.toFixed(6));
        if (this.nextComponent.isOpen()) {
          this.forwardEntity();
        }
      };
      //this.activate = function(nextState) {
      //  if (nextState == "clearEntryDisplay") {
      //    this.clearEntryDisplay();
      //  } else if (nextState == "clearExitDisplay") {
      //    this.clearExitDisplay();
      //  } else {
      //    errorUndefinedAdvanceState(this.entityID,this.nextState);
      //  }
      //};  //this.activate

    }  //QueueComponent1

    //##default parameters##
    //function ProcessComponent(displayDelay, processTime, maxCapacity = 1, routingTable = [1.0]) {
    //function ProcessComponent(displayDelay, processTime) {
      //var maxCapacity = arguments.length > 1 && arguments[2] !== undefined ? arguments[2] : 1;
      //var routingTable = arguments.length > 2 && arguments[3] !== undefined ? arguments[3] : [1.0];
    function ProcessComponent(processTime, processTimeSwitch, maxCapacity, routingTable) {
      if (typeof maxCapacity === "undefined") {maxCapacity = 1;}
      if (typeof routingTable === "undefined") {routingTable = [1.0];}
      //generally exclusive, should always be fed by a queue or at least "protected" by a status-based diversion component
      setOfComponents.push(this);
      this.componentID = getNewComponentID();
      this.componentType = "Process";
      this.componentName = "Process";
      this.componentGroup = "Process";
      this.routingMethod = 1;  //1: one connection, 2: distribution, 3 routing
      this.previousComponentList = [];
      this.previousComponentCount = 0;
      this.nextComponentList = [];
      this.nextComponentCount = 0;
      this.nextComponentIDList = [];
      this.processTime = processTime;
      this.processTimeSwitch = processTimeSwitch;
      this.maxCapacity = maxCapacity;
      if (this.maxCapacity < Infinity) {
        this.exclusive = true;
      } else {
        this.exclusive = false;
      }
      this.savedDestination = -1;
      this.previousComponentIndex = 0;
      this.nextComponentIndex = 0;
      this.entityQueue = [];
      //this.pullQueue = [];
      this.routingTable = routingTable;
      this.openStatus = true;
      this.entryTime = "";
      this.entryEntityID = "";
      this.exitTime = "";
      this.exitEntityID = "";
      this.exitResidenceTime = "";
      this.countInQueue = 0;
      this.countInProcess = 0;
      this.activity = "";
      this.endEntryDisplayTime = 0;
      this.endExitDisplayTime = 0;
      this.endAllDisplayTime = 0;
      this.displayDelay = 0;
      this.graphic = null;

      this.reset = function() {
        this.previousComponentIndex = this.previousComponentCount - 1;
        this.nextComponentIndex = this.nextComponentCount - 1;
        this.entityQueue = [];
        this.openStatus = true;
        this.savedDestination = -1;
        this.entryTime = "";
        this.entryEntityID = "";
        this.exitTime = "";
        this.exitEntityID = "";
        this.exitResidenceTime = "";
        this.countInQueue = 0;
        this.countInProcess = 0;
        this.activity = "";
        this.endEntryDisplayTime = 0;
        this.endExitDisplayTime = 0;
        this.endAllDisplayTime = 0;
      };
      this.assignPreviousComponent = function(prev) {  //TODO-: implement code that makes this actually work
        this.previousComponentList.push(prev);
        this.previousComponentCount++;
        this.previousComponentIndex = this.previousComponentCount - 1;
        //TODO-: assign this automatically when upstream link and exclusive paths are required?
      };
      this.assignNextComponent = function(next) {  //ProcessComponent
        this.nextComponentList.push(next);
        this.nextComponentCount++;
        this.nextComponentIndex = this.nextComponentCount - 1;
        next.assignPreviousComponent(this);
        //TODO-: automatically assign upstream link if downstream component is exclusive?
      };
      this.verifyLinks = function() {
        var i;
        var error = "";
        if (this.nextComponentCount > 0) {
          for (i = 0; i < this.nextComponentCount; i++) {  //>
            if (this.nextComponentList[i]) {  //link exists
              if (typeof this.nextComponentList[i] === "object") {  //link points to an object
                if ("componentType" in this.nextComponentList[i]) {  //object contains member componentType
                  if ((this.nextComponentList[i].componentType == "Arrivals") ||
                      (this.nextComponentList[i].componentType == "Entry")) {
                    error += this.componentType + " comp. " + this.componentID + " next comp. list element " + i + " is not an allowed comp.\n";
                  }
                } else {
                  //linked object does not contain member componentType
                  error += this.componentType + " comp. " + this.componentID + " next comp. list item " + i + " does not have componentType\n";
                }
              } else {
                //link points to something that is not an object
                error += this.componentType + " comp. " + this.componentID + " next comp. list item " + i + " is not an object\n";
              }
            } else {
              //link that should exist does not
              error += this.componentType + " comp. " + this.componentID + " next comp. list item " + i + " does not exist\n";
            }
          }
        } else {
          error += this.componentType + " comp. " + this.componentID + " has index of zero next components\n";
        }
        if (this.previousComponentCount > 0) {
          for (i = 0; i < this.previousComponentCount; i++) {  //>
            if (this.previousComponentList[i]) {  //link exists
              if (typeof this.previousComponentList[i] === "object") {  //link points to an object
                if ("componentType" in this.previousComponentList[i]) {  //object contains member componentType
                  if ((this.previousComponentList[i].componentType == "Arrivals") ||
                      (this.previousComponentList[i].componentType == "Exit")) {
                    error += this.componentType + " comp. " + this.componentID + " previous comp. list element " + i + " is not an allowed comp.\n";
                  }
                } else {
                  //linked object does not contain member componentType
                  error += this.componentType + " comp. " + this.componentID + " previous comp. list item " + i + " does not have componentType\n";
                }
              } else {
                //link points to something that is not an object
                error += this.componentType + " comp. " + this.componentID + " previous comp. list item " + i + " is not an object\n";
              }
            } else {
              //link that should exist does not
              error += this.componentType + " comp. " + this.componentID + " previous comp. list item " + i + " does not exist\n";
            }
          }
        } else {
          error += this.componentType + " comp. " + this.componentID + " has index of zero previous components\n";
        }
        return error;
      };

      this.getNextComponentIDs = function() {
        for (var i = 0; i < this.nextComponentCount; i++) {
          if (this.nextComponentList[i].getComponentType() != "Path") {
            this.nextComponentIDList[i] = this.nextComponentList[i].getComponentID();
          } else {
            this.nextComponentIDList[i] = this.nextComponentList[i].passComponentID();
          }
        }
      };

      this.getComponentID = function() {
        return this.componentID;
      };
      this.getComponentType = function() {  //ProcessComponent
        return this.componentType;
      };
      this.getComponentName = function() {
        return this.componentName;
      };
      this.setComponentName = function(componentName) {
        this.componentName = componentName;
      };
      this.getComponentGroup = function() {
        return this.componentGroup;
      };
      this.setComponentGroup = function(componentGroup) {
        this.componentGroup = componentGroup;
        addToGroupStatsNameListWrapper(componentGroup);
      };
      this.getExclusive = function() {
        return this.exclusive;
      };
      //this.setExclusive = function(exclusive) {
      //  this.exclusive = exclusive;
      //};
      this.getProcessTime = function() {
        return this.processTime;
      };
      this.getProcessTimeSwitch = function() {
        return this.processTimeSwitch;
      };
      this.setProcessTimeSwitch = function(processTimeSwitch) {
        this.processTimeSwitch = processTimeSwitch;
      };
      this.getMaxCapacity = function() {
        return this.maxCapacity;
      };
      this.setMaxCapacity = function(maxCapacity) {
        this.maxCapacity = maxCapacity;
      };
      this.getOpenStatus = function() {
        return this.openStatus;
      };
      this.setOpenStatus = function(openStatus) {
        this.openStatus = openStatus;
      };
      this.getForwardAttemptTime = function() {
        if (this.countInQueue > 0) {
          return this.entityQueue[this.countInQueue - 1].getForwardAttemptTime();
        } else {
          return Infinity;
        }
      };
      this.getRoutingMethod = function() {
        return this.routingMethod;
      };
      this.setRoutingMethod = function(routingMethod) {
        this.routingMethod = routingMethod;
      };
      this.getEntryTime = function() {
        return this.entryTime;
      };
      this.getEntryEntityID = function() {
        return this.entryEntityID;
      };
      this.getExitTime = function() {
        return this.exitTime;
      };
      this.getExitEntityID = function() {
        return this.exitEntityID;
      };
      this.getExitResidenceTime = function() {
        return this.exitResidenceTime;
      };
      this.getCountInQueue = function() {
        return this.countInQueue;
      };
      this.getCountInProcess = function() {
        return this.countInProcess;
      };
      this.getActivity = function() {
        return this.activity;
      };
      this.getEndEntryDisplayTime = function() {
        return this.endEntryDisplayTime;
      };
      this.getEndExitDisplayTime = function() {
        return this.endExitDisplayTime;
      };
      this.getEndAllDisplayTime = function() {
        return this.endAllDisplayTime;
      };

      this.dataGroup = new DisplayGroup1();
      this.defineDataGroup = function(displayDelay, x, y, vw, bc, vc, lc) {
        this.displayDelay = displayDelay;
        this.dataGroup.define(this.componentID, this.componentType, x, y, vw, bc, vc, lc);
      };
      this.dataGroup.addValue(this.entryEntityID, "Entry ID", "integer");
      this.dataGroup.addValue(this.countInQueue, "# In Process", "numdec", "integer");
      this.dataGroup.addValue(this.exitEntityID, "Exit ID", "integer");
      this.dataGroup.addValue(this.exitResidenceTime, "Resdnce Tm", "numdec", 5);
      this.dataGroup.addValue(this.activity, "Activity", "text");

      this.assignDisplayValues = function() {
        this.dataGroup.valueList[0].value = this.entryEntityID;
        this.dataGroup.valueList[1].value = this.countInQueue;
        this.dataGroup.valueList[2].value = this.exitEntityID;
        this.dataGroup.valueList[3].value = this.exitResidenceTime;
        this.dataGroup.valueList[4].value = this.activity;
        if (this.exclusive) {
          if (this.openStatus) {
            this.dataGroup.setBorderColor("#00FF00");
          } else {
            this.dataGroup.setBorderColor("#FF0000");
          }
        }
      };
      this.drawData = function() {  //ProcessComponent
        this.assignDisplayValues();
        this.dataGroup.drawBasic();
      };

      this.defineGraphic = function(graphic) {
        this.graphic = graphic;
      };
      this.updateGraphic = function() {
        this.graphic.setTraverseValue(this.countInProcess);
        this.graphic.setCountValue(this.countInQueue);
      };

      this.isOpen = function() {  //ProcessComponent
        if (this.exclusive) {
          if (this.currentCount() < this.maxCapacity) {
            this.openStatus = true;
          } else {
            this.openStatus = false;
          }
          for (var i = 0; i < this.previousComponentCount; i++) {
            if (this.previousComponentList[i].getComponentType() == "Path") {
              this.previousComponentList[i].setPreviousStatus(this.openStatus);  //this may only be needed to determine open/closed status for display, count <=> capacity used when something is trying to enter
            }
          }
        }
        return this.openStatus;  //if not exclusive should be set to true by default
      };
      this.clearEntryDisplay = function() {
        //only clear display if a new one hasn't started a new timer
        if (globalSimClock >= this.endEntryDisplayTime) {
          this.entryTime = "";
          this.entryEntityID = "";
        }
        if (globalSimClock >= this.endAllDisplayTime) {
          this.activity = "";
        }
        //displayProgressText("Process entry "+this.componentID+" clears at time "+globalSimClock.toFixed(6));
      };
      this.clearExitDisplay = function() {
        //only clear display if a new one hasn't started a new timer
        if (globalSimClock >= this.endExitDisplayTime) {
          this.exitTime = "";
          this.exitEntityID = "";
          this.exitResidenceTime = "";
        }
        if (globalSimClock >= this.endAllDisplayTime) {
          this.activity = "";
        }
        //displayProgressText("Process exit "+this.componentID+" clears at time "+globalSimClock.toFixed(6));
      };
      this.currentCount = function() {
        var count = 0;
        if (this.exclusive) {
          //start with entities already in component
          count = this.countInQueue;
          //add entities in feeding paths
          for (var i = 0; i < this.previousComponentCount; i++) {
            if (this.previousComponentList[i].componentType == "Path") {  //TODO- consider adding test for whether path is boundary component for associated exclusive group of components //do this using no-time/no-space control component to define boundary
              count += this.previousComponentList[i].currentCount();
            }
          }
        }
        return count;
      };
      this.pullFromPrevious = function() {  //ProcessComponent
        var oldest = this.previousComponentList[0].getForwardAttemptTime();
        var oldestIndex = 0;
        for (var i = 1; i < this.previousComponentCount; i++) {
          var age = this.previousComponentList[i].getForwardAttemptTime();
          if (age < oldest) {
            oldestIndex = i;
          }
        }
        if (this.previousComponentList[oldestIndex].getComponentType() != "Path") {
          if (this.previousComponentList[oldestIndex].getComponentType() != "Entry") {
            //TODO: this should call forward entity in a way that ensures that previous component only sends entity to where it is requested and if one is available and if this is a legitimate destination
            this.previousComponentList[oldestIndex].forwardEntity(this.componentID);
          }
        } else {
          displayProgressText("Process comp. " + this.componentID + " pulls from previous (" + oldestIndex + ") at time " + globalSimClock.toFixed(6));
          this.previousComponentList[oldestIndex].pullFromPrevious(this.componentID);
        }
      };
      this.nextOpen = function() {
        var startIndex = this.nextComponentIndex;
        var tempIndex = startIndex;
        do {
          tempIndex++;
          if (tempIndex >= this.nextComponentCount) {
            tempIndex = 0;
          }
          if (this.nextComponentList[tempIndex].isOpen()) {
            //open link found, update and return nextComponentIndex
            return tempIndex;
          }
        } while (tempIndex != startIndex);
        return -1;  //no open links found, leave nextComponentIndex unchanged
      };
      this.processComplete = function() {
        this.countInProcess--;   //TODO: ensure handled properly if process time is zero //prob. not applicable
        //figure out which entity just finished processing
        var tempID = this.entityQueue[this.countInProcess].entityID;  //TODO: this works for FIFO, but not necessarily for other logics
        this.entityQueue[this.countInProcess].setForwardAttemptTime(globalSimClock);
        displayProgressText("Process comp. " + this.componentID + " entity: " + tempID + " processed at " + globalSimClock.toFixed(6));
        if (this.countInQueue - this.countInProcess == 1) {  //don't bother trying to forward unless this is the lead item in the queue
          this.forwardEntity();
        }
      };
      //##default parameters##
      //this.forwardEntity = function(destIndex = -1) {  //ProcessComponent
      //this.forwardEntity = function() {  //ProcessComponent
        ///var routingTable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
      this.forwardEntity = function(destIndex) {  //ProcessComponent
        if (typeof destIndex === "undefined") {destIndex = -1;}
        var dest = -1;
        if (destIndex >= 0) {  //pull request from a specific downstream component, must send entity there
          if (this.routingMethod == 1) { //single connection, nothing to do
            dest = 0;
          } else if (this.routingMethod == 2) { //distribution, send to any request
            dest = 0;
            while ((this.nextComponentIDList[dest] != destIndex) && (dest < this.nextComponentCount)) {  //second test should not be needed, loop can't fail to return valid result
              dest++;
            }
          } else if (this.routingMethod == 3) {  //model routing logic, TODO: don't forward if not desired destination
            dest = 0;
            while ((this.nextComponentIDList[dest] != destIndex) && (dest < this.nextComponentCount)) {  //second test should not be needed, loop can't fail to return valid result
              dest++;
            }
          }
          dummy2 = 0;
        } else {
          if (this.routingMethod == 1) {  //single connection
            if (this.nextComponentList[0].isOpen()) {
              dest = 0;
            }
          } else if (this.routingMethod == 2) {  //distribution
            var nextIndex = this.nextOpen();
            if (nextIndex >= 0) {
              dest = nextIndex;
              //this.nextComponentIndex = dest;
            }
          } else if (this.routingMethod == 3) {  //model routing logic
            if (this.savedDestination >= 0) {
              dest = this.savedDestination;
            } else {
              dest = 0;
              var test = Math.random();
              //need access to entity type but can't pop it off queue here
              var index = this.countInQueue - 1;
              if (index >= 0) {
                index = entityDiversionPercentIndex(this.entityQueue[index]);  //get head item in queue and find out what type it is
              } else {
                index = 0;  //nothing in queue, following code will work but nothing will be popped and processed below
              }
              while (test > this.routingTable[index][dest]) {
                dest++;
              }
              if (dest <= this.nextComponentCount) {
                if (!this.nextComponentList[dest].isOpen()) {
                  dest = -1;
                }
              } else {
                alert("Process comp. tried to assign destination with too high of an index")
              }
              if (dest >= 0) {
                this.savedDestination = dest;  //ensure that once destination is determined for this entity that we don't keep changing it
              }
            }
          } else {  //0 uninitialized or anything else
            alert("comp. " + this.componentID + " incorrect routing method: " + this.routingMethod);
          }
        }
        if (dest >= 0) {
          if (this.countInQueue > this.countInProcess) {
            var entity = this.entityQueue.pop();  //TODO-: are we testing to ensure the next entity is really available
            if (entity) {  //TODO-: since we've tested above this should not be necessary
              //calculate how long item was in process
              this.exitResidenceTime = globalSimClock - entity.getLocalEntryTime();
              this.exitTime = globalSimClock;
              this.exitEntityID = entity.entityID;
              this.activity = "forward entity";
              this.endExitDisplayTime = globalSimClock + this.displayDelay;
              this.endAllDisplayTime = this.endExitDisplayTime;
              advance(this.displayDelay, this, "clearExitDisplay");
              displayProgressText("Process comp. " + this.componentID + " forwards entity: " + this.exitEntityID + " at time " + globalSimClock.toFixed(6));

              this.countInQueue--;
              //should be open now
              if (this.exclusive) {
                displayProgressText("Process comp. " + this.componentID + " calls pull from previous at time " + globalSimClock.toFixed(6));
                if (!this.openStatus) {
                  this.pullFromPrevious(); //TODO: call this with a modest (~1 sec) delay to account for reaction time? //may or may not successfully get an entity but should always be called
                }
              }
              this.isOpen();
              this.nextComponentIndex = dest;
              this.savedDestination = -1;  //clear old choice when entity successfully forwarded
              this.nextComponentList[dest].receiveEntity(entity);
              //record stats
              if (this.nextComponentList[dest].getComponentGroup() != entity.getComponentGroup()) {  //truly leaving a component group along the current connection
                recordGroupStatsWrapper(this.componentGroup, entity.getComponentGroupEntryTime(), entity);
              }
            }
          }
        }
      };
      this.receiveEntity = function(entity) {  //ProcessComponent
        //receive the entity
        entity.setLocalEntryTime();  //record time entity entered process
        if (entity.getComponentGroup() != this.componentGroup) {
          entity.setComponentGroup(this.componentGroup);
          entity.setComponentGroupEntryTime(globalSimClock);
          recordGroupStatsSystemEntryWrapper(this.componentGroup,entity);
        }
        entity.setForwardAttemptTime(Infinity);
        entity.setPermission(false);  //entity has reached end of related components group, permission no longer matters
        this.entityQueue.unshift(entity);
        this.countInQueue++;
        this.countInProcess++;  //TODO: handle if process time is zero?
        this.isOpen();
        //display what was done
        this.entryTime = globalSimClock;
        this.entryEntityID = entity.entityID;
        this.activity = "receive entity";
        //set timer to clear the display after a bit
        this.endEntryDisplayTime = globalSimClock + this.displayDelay;
        this.endAllDisplayTime = this.endEntryDisplayTime;
        advance(this.displayDelay, this, "clearEntryDisplay");
        //set timer for the process duration
        var pTime = this.processTime[entityProcessTimeIndex(entity,this.processTimeSwitch)];
        advance(pTime, this, "processComplete");
        displayProgressText("Process comp. " + this.componentID + " receives entity: " + this.entryEntityID + " at time " + globalSimClock.toFixed(6));
      };
      this.activate = function(nextState) {
        if (nextState == "clearEntryDisplay") {
          this.clearEntryDisplay();
        } else if (nextState == "clearExitDisplay") {
          this.clearExitDisplay();
        } else if (nextState == "processComplete") {
          this.processComplete();
        } else {
          errorUndefinedAdvanceState(this.entityID, this.nextState);
        }
      };  //this.activate

    }  //ProcessComponent

    function CombinedComponent(traversalTime, processTime, processTimeSwitch, queueCapacity, processCapacity, routingTable) {
      if (typeof queueCapacity === "undefined") {queueCapacity = Infinity;}
      if (typeof processCapacity === "undefined") {processCapacity = 1;}
      if (typeof routingTable === "undefined") {routingTable = [1.0];}
      setOfComponents.push(this);
      this.componentID = getNewComponentID();
      this.componentType = "Combined";
      this.componentName = "Combined";
      this.componentGroup = "Combined";
      this.routingMethod = 3;  //1: one connection, 2: distribution, 3 routing
      this.previousComponentList = [];
      this.previousComponentCount = 0;
      this.nextComponentList = [];
      this.nextComponentCount = 0;
      this.nextComponentIDList = [];
      this.traversalTime = traversalTime;
      this.processTime = processTime;
      this.processTimeSwitch = processTimeSwitch;
      this.queueCapacity = queueCapacity;
      this.processCapacity = processCapacity;
      if (this.queueCapacity < Infinity) {
        this.exclusive = true;
      } else {
        this.exclusive = false;
      }
      this.savedDestination = -1;
      this.previousComponentIndex = 0;
      this.nextComponentIndex = 0;
      this.entityQueue = [];
      this.processQueue = [];
      this.routingTable = routingTable;
      this.openStatus = true;
      this.entryTime = "";
      this.entryEntityID = "";
      this.exitTime = "";
      this.exitEntityID = "";
      this.exitResidenceTime = "";
      this.countInQueue = 0;
      this.countInTraversal = 0;
      this.countInProcessQueue = 0;
      this.countInProcess = 0;
      this.activity = "";
      this.endEntryDisplayTime = 0;
      this.endExitDisplayTime = 0;
      this.endAllDisplayTime = 0;
      this.displayDelay = 0;
      this.graphic = null;

      this.reset = function() {
        this.savedDestination = -1;
        this.previousComponentIndex = this.previousComponentCount - 1;
        this.nextComponentIndex = this.nextComponentCount - 1;
        this.entityQueue = [];
        this.processQueue = [];
        this.openStatus = true;
        this.entryTime = "";
        this.entryEntityID = "";
        this.exitTime = "";
        this.exitEntityID = "";
        this.exitResidenceTime = "";
        this.countInQueue = 0;
        this.countInTraversal = 0;
        this.activity = "";
        this.endEntryDisplayTime = 0;
        this.endExitDisplayTime = 0;
        this.endAllDisplayTime = 0;
      };
      this.assignPreviousComponent = function(prev) {
        this.previousComponentList.push(prev);
        this.previousComponentCount++;
        this.previousComponentIndex = this.previousComponentCount - 1;
      };
      this.assignNextComponent = function(next) {  //CombinedComponent
        this.nextComponentList.push(next);
        this.nextComponentCount++;
        this.nextComponentIndex = this.nextComponentCount - 1;
        next.assignPreviousComponent(this);
      };
      this.getNextComponentIDs = function() {
        for (var i = 0; i < this.nextComponentCount; i++) {
          if (this.nextComponentList[i].getComponentType() != "Path") {
            this.nextComponentIDList[i] = this.nextComponentList[i].getComponentID();
          } else {
            this.nextComponentIDList[i] = this.nextComponentList[i].passComponentID();
          }
        }
      };
      this.verifyLinks = function() {
        var i;
        var error = "";
        if (this.nextComponentCount > 0) {
          for (i = 0; i < this.nextComponentCount; i++) {  //>
            if (this.nextComponentList[i]) {  //link exists
              if (typeof this.nextComponentList[i] === "object") {  //link points to an object
                if ("componentType" in this.nextComponentList[i]) {  //object contains member componentType
                  if ((this.nextComponentList[i].componentType == "Arrivals") ||
                      (this.nextComponentList[i].componentType == "Entry")) {
                    error += this.componentType + " comp. " + this.componentID + " next comp. list element " + i + " is not an allowed comp.\n";
                  }
                } else {
                  //linked object does not contain member componentType
                  error += this.componentType + " comp. " + this.componentID + " next comp. list item " + i + " does not have componentType\n";
                }
              } else {
                //link points to something that is not an object
                error += this.componentType + " comp. " + this.componentID + " next comp. list item " + i + " is not an object\n";
              }
            } else {
              //link that should exist does not
              error += this.componentType + " comp. " + this.componentID + " next comp. list item " + i + " does not exist\n";
            }
          }
        } else {
          error += this.componentType + " comp. " + this.componentID + " has index of zero next components\n";
        }
        if (this.previousComponentCount > 0) {
          for (i = 0; i < this.previousComponentCount; i++) {  //>
            if (this.previousComponentList[i]) {  //link exists
              if (typeof this.previousComponentList[i] === "object") {  //link points to an object
                if ("componentType" in this.previousComponentList[i]) {  //object contains member componentType
                  if ((this.previousComponentList[i].componentType == "Arrivals") ||
                      (this.previousComponentList[i].componentType == "Exit")) {
                    error += this.componentType + " comp. " + this.componentID + " previous comp. list element " + i + " is not an allowed comp.\n";
                  }
                } else {
                  //linked object does not contain member componentType
                  error += this.componentType + " comp. " + this.componentID + " previous comp. list item " + i + " does not have componentType\n";
                }
              } else {
                //link points to something that is not an object
                error += this.componentType + " comp. " + this.componentID + " previous comp. list item " + i + " is not an object\n";
              }
            } else {
              //link that should exist does not
              error += this.componentType + " comp. " + this.componentID + " previous comp. list item " + i + " does not exist\n";
            }
          }
        } else {
          error += this.componentType + " comp. " + this.componentID + " has index of zero previous components\n";
        }
        return error;
      };

      this.getComponentID = function() {
        return this.componentID;
      };
      this.getComponentType = function() {  //CombinedComponent
        return this.componentType;
      };
      this.getComponentName = function() {
        return this.componentName;
      };
      this.setComponentName = function(componentName) {
        this.componentName = componentName;
      };
      this.getComponentGroup = function() {
        return this.componentGroup;
      };
      this.setComponentGroup = function(componentGroup) {
        this.componentGroup = componentGroup;
        addToGroupStatsNameListWrapper(componentGroup);
      };
      this.getExclusive = function() {
        return this.exclusive;
      };
      //this.setExclusive = function(exclusive) {
      //  this.exclusive = exclusive;
      //};
      this.getTraversalTime = function() {
        return this.traversalTime;
      };
      this.getProcessTime = function() {
        return this.processTime;
      };
      this.getProcessTimeSwitch = function() {
        return this.processTimeSwitch;
      };
      this.setProcessTimeSwitch = function(processTimeSwitch) {
        this.processTimeSwitch = processTimeSwitch;
      };
      this.getQueueCapacity = function() {
        return this.queueCapacity;
      };
      this.setQueueCapacity = function(queueCapacity) {
        this.queueCapacity = queueCapacity;
      };
      this.getProcessCapacity = function() {
        return this.processCapacity;
      };
      this.setProcessCapacity = function(processCapacity) {
        this.processCapacity = processCapacity;
      };
      this.getOpenStatus = function() {
        return this.openStatus;
      };
      this.setOpenStatus = function(openStatus) {
        this.openStatus = openStatus;
      };
      this.getForwardAttemptTime = function() {
        if (this.countInProcessQueue > this.countInProcess) {
          return this.processQueue[this.countInProcessQueue - 1].getForwardAttemptTime();
        } else {
          return Infinity;
        }
      };
      this.getRoutingMethod = function() {
        return this.routingMethod;
      };
      this.setRoutingMethod = function(routingMethod) {
        this.routingMethod = routingMethod;
      };
      this.getEntryTime = function() {
        return this.entryTime;
      };
      this.getEntryEntityID = function() {
        return this.entryEntityID;
      };
      this.getExitTime = function() {
        return this.exitTime;
      };
      this.getExitEntityID = function() {
        return this.exitEntityID;
      };
      this.getExitResidenceTime = function() {
        return this.exitResidenceTime;
      };
      this.getCountInQueue = function() {
        return this.countInQueue;
      };
      this.getCountInTraversal = function() {
        return this.countInTraversal;
      };
      this.getCountInProcessQueue = function() {
        return this.countInProcessQueue;
      };
      this.getCountInProcess = function() {
        return this.countInProcess;
      };
      this.getActivity = function() {
        return this.activity;
      };
      this.getEndEntryDisplayTime = function() {
        return this.endEntryDisplayTime;
      };
      this.getEndExitDisplayTime = function() {
        return this.endExitDisplayTime;
      };
      this.getEndAllDisplayTime = function() {
        return this.endAllDisplayTime;
      };

      this.dataGroup = new DisplayGroup1();
      this.defineDataGroup = function(displayDelay, x, y, vw, bc, vc, lc) {
        this.displayDelay = displayDelay;
        this.dataGroup.define(this.componentID, this.componentType, x, y, vw, bc, vc, lc);
      };
      this.dataGroup.addValue(this.entryEntityID, "Entry ID", "integer");
      this.dataGroup.addValue(this.countInQueue, "# In Queue", "integer");
      this.dataGroup.addValue(this.countInTraversal, "# Traversing", "integer");
      this.dataGroup.addValue(this.maxCapacity, "Capacity", "integer");
      this.dataGroup.addValue(this.exitEntityID, "Exit ID", "integer");
      //this.dataGroup.addValue(this.exitResidenceTime,"Resdnce Tm","numdec",5);
      this.dataGroup.addValue(this.nextComponentIndex, "Next comp.", "integer");
      this.dataGroup.addValue(this.activity, "Activity", "text");
      this.dataGroup.addValue(this.getForwardAttemptTime(), "Fwd Attmpt", "numdec", 5);

      this.assignDisplayValues = function() {
        this.dataGroup.valueList[0].value = this.entryEntityID;
        this.dataGroup.valueList[1].value = this.countInQueue;
        this.dataGroup.valueList[2].value = this.countInTraversal;
        this.dataGroup.valueList[3].value = this.maxCapacity;
        this.dataGroup.valueList[4].value = this.exitEntityID;
        //this.dataGroup.valueList[5].value = this.exitResidenceTime;
        this.dataGroup.valueList[5].value = this.nextComponentIndex;
        this.dataGroup.valueList[6].value = this.activity;
        this.dataGroup.valueList[7].value = this.getForwardAttemptTime();
        if (this.exclusive) {
          if (this.openStatus) {
            this.dataGroup.setBorderColor("#00FF00");
          } else {
            this.dataGroup.setBorderColor("#FF0000");
          }
        }
      };

      this.drawData = function() {  //Combined component
        this.assignDisplayValues();
        this.dataGroup.drawBasic();
      };

      this.defineGraphic = function(graphic) {
        this.graphic = graphic;
      };
      this.updateGraphic = function() {
        this.graphic.setTraverseValue(this.countInTraversal);
        this.graphic.setCountValue(this.countInQueue);
      };

      this.isOpen = function() {  //CombinedComponent
        if (this.exclusive) {
          if (this.currentCount() < (this.queueCapacity + this.processCapacity)) {
            this.openStatus = true;
          } else {
            this.openStatus = false;
          }
          for (var i = 0; i < this.previousComponentCount; i++) {
            if (this.previousComponentList[i].getComponentType() == "Path") {
              this.previousComponentList[i].setPreviousStatus(this.openStatus);  //this may only be needed to determine open/closed status for display, count <=> capacity used when something is trying to enter
            }
          }
        }
        return this.openStatus;  //if not exclusive should be set to true by default
      };
      this.clearEntryDisplay = function() {
        //only clear display if a new one hasn't started a new timer
        if (globalSimClock >= this.endEntryDisplayTime) {
          this.entryTime = "";
          this.entryEntityID = "";
        }
        if (globalSimClock >= this.endAllDisplayTime) {
          this.activity = "";
        }
        //displayProgressText("Queue entry "+this.componentID+" clears at time "+globalSimClock.toFixed(6));
      };
      this.clearExitDisplay = function() {
        //only clear display if a new one hasn't started a new timer
        if (globalSimClock >= this.endExitDisplayTime) {
          this.exitTime = "";
          this.exitEntityID = "";
          this.exitResidenceTime = "";
        }
        if (globalSimClock >= this.endAllDisplayTime) {
          this.activity = "";
        }
        //displayProgressText("Queue exit "+this.componentID+" clears at time "+globalSimClock.toFixed(6));
      };
      this.currentCount = function() {
        var count = 0;
        if (this.exclusive) {
          //start with entities already in component
          count = this.countInQueue + this.countInProcessQueue;
          //add entities in feeding paths
          for (var i = 0; i < this.previousComponentCount; i++) {
            if (this.previousComponentList[i].componentType == "Path") {  //TODO: consider adding test for whether path is boundary component for associated exclusive group of components -- done this by inserting no-time/no-space control components
              count += this.previousComponentList[i].currentCount();
            }
          }
        }
        return count;
      };
      this.pullFromPrevious = function() {  //CombinedComponent
        var oldest = this.previousComponentList[0].getForwardAttemptTime();
        var oldestIndex = 0;
        for (var i = 1; i < this.previousComponentCount; i++) {
          var age = this.previousComponentList[i].getForwardAttemptTime();
          if (age < oldest) {
            oldestIndex = i;
          }
        }
        if (this.previousComponentList[oldestIndex].getComponentType() != "Path") {
          if (this.previousComponentList[oldestIndex].getComponentType() != "Entry") {
            //TODO: this should call forward entity in a way that ensures that previous component only sends entity to where it is requested and if one is available and if this is a legitimate destination
            this.previousComponentList[oldestIndex].forwardEntity(this.componentID);
          }
        } else {
          displayProgressText("Combined comp. " + this.componentID + " pulls from previous at time " + globalSimClock.toFixed(6));
          this.previousComponentList[oldestIndex].pullFromPrevious(this.componentID);
        }
      };
      this.nextOpen = function() {
        var startIndex = this.nextComponentIndex;
        var tempIndex = startIndex;
        do {
          tempIndex++;
          if (tempIndex >= this.nextComponentCount) {
            tempIndex = 0;
          }
          if (this.nextComponentList[tempIndex].isOpen()) {
            //open link found, update and return nextComponentIndex
            return tempIndex;
          }
        } while (tempIndex != startIndex);
        return -1;  //no open links found, leave nextComponentIndex unchanged
      };
      this.queueToProcess = function() {
        if (this.countInQueue > this.countInTraversal) {  //an entity is available to move
          var entity = this.entityQueue.pop();
          this.countInQueue--;
          this.processQueue.unshift(entity);
          this.countInProcessQueue++;
          this.countInProcess++;
          var pTime = this.processTime[entityProcessTimeIndex(entity,this.processTimeSwitch)];
          advance(pTime, this, "processComplete", entity);
          //should be open now
          if (this.exclusive) {
            if (!this.openStatus) {
              displayProgressText("Combined comp. " + this.componentID + " calls pull from previous at time " + globalSimClock.toFixed(6));
              this.pullFromPrevious(); //TODO: call this with a modest (~1 time unit) delay to account for reaction time? //may or may not successfully get an entity but should always be called
            }
          }
        }
      };
      this.traverseComplete = function() {
        this.countInTraversal--;   //TODO: ensure handled properly if traversal time is zero
        //figure out which entity just finished traversing
        var tempID = this.entityQueue[this.countInTraversal].entityID;  //TODO: this works for FIFO, but not necessarily for other logics
        //this.entityQueue[this.countInTraversal].setForwardAttemptTime(globalSimClock);
        displayProgressText("Queue comp. " + this.componentID + " entity: " + tempID + " trav. at time " + globalSimClock.toFixed(6));
        if (this.countInQueue - this.countInTraversal == 1) {  //don't bother trying to forward unless this is the lead item in the queue
          if (this.countInProcessQueue < this.processCapacity) {  //is there space in the process queue
            this.queueToProcess();
          }
        }
      };
      this.processComplete = function() {
        this.countInProcess--;
        //figure out which entity just finished processing
        var tempID = this.processQueue[this.countInProcess].entityID;  //TODO: this works for FIFO, but not necessarily for other logics
        this.processQueue[this.countInProcess].setForwardAttemptTime(globalSimClock);
        displayProgressText("Combined comp. " + this.componentID + " entity: " + tempID + " processed at " + globalSimClock.toFixed(6));
        if (this.countInProcessQueue - this.countInProcess == 1) {  //don't bother trying to forward unless this is the lead item in the queue
          this.forwardEntity();
        }
      };
      //##default parameters##
      //this.forwardEntity = function(destIndex = -1) {  //CombinedComponent
      //this.forwardEntity = function() {  //CombinedComponent
        ///var routingTable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
      this.forwardEntity = function(destIndex) {  //CombinedComponent
        if (typeof destIndex === "undefined") {destIndex = -1;}
        var dest = -1;
        if (destIndex >= 0) {  //pull request from a specific downstream component, must send entity there
          if (this.routingMethod == 1) { //single connection, nothing to do
            dest = 0;
          } else if (this.routingMethod == 2) { //distribution, send to any request
            dest = 0;
            while ((this.nextComponentIDList[dest] != destIndex) && (dest < this.nextComponentCount)) {  //second test should not be needed, loop can't fail to return valid result
              dest++;
            }
          } else if (this.routingMethod == 3) {  //model routing logic, TODO: don't forward if not desired destination
            dest = 0;
            while ((this.nextComponentIDList[dest] != destIndex) && (dest < this.nextComponentCount)) {  //second test should not be needed, loop can't fail to return valid result
              dest++;
            }
          }
          dummy2 = 0;
        } else {
          if (this.routingMethod == 1) {  //single connection
            if (this.nextComponentList[0].isOpen()) {
              dest = 0;
            }
          } else if (this.routingMethod == 2) {  //distribution
            var nextIndex = this.nextOpen();
            if (nextIndex >= 0) {
              dest = nextIndex;
              //this.nextComponentIndex = dest;
            }
          } else if (this.routingMethod == 3) {  //model routing logic
            if (this.savedDestination >= 0) {
              dest = this.savedDestination;
            } else {
              dest = 0;
              var test = Math.random();
              //need access to entity type but can't pop it off queue here
              var index = this.countInQueue - 1;
              if (index >= 0) {
                index = entityDiversionPercentIndex(this.entityQueue[index]);  //get head item in queue and find out what type it is
              } else {
                index = 0;  //nothing in queue, following code will work but nothing will be popped and processed below
              }
              while (test > this.routingTable[index][dest]) {
                dest++;
              }
              if (dest <= this.nextComponentCount) {
                if (!this.nextComponentList[dest].isOpen()) {
                  dest = -1;  //this works only because destinations are unique (i.e., can't send to multiple parallel types/processes, must send to a single queue feeding them)
                }
              } else {
                alert("Queue comp. tried to assign destination with too high of an index")
              }
              if (dest >= 0) {
                this.savedDestination = dest;
              }
            }
          } else {  //0 uninitialized or anything else
            alert("comp. " + this.componentID + " incorrect routing method: " + this.routingMethod);
          }
        }
        if (dest >= 0) {
          if (this.countInProcessQueue > this.countInProcess) {
            var entity = this.processQueue.pop();  //TODO-: are we testing to ensure the next entity is really available
            //calculate how long item was in queue
            this.exitResidenceTime = globalSimClock - entity.getLocalEntryTime();
            //now use this to calculate stats for the interval
            this.exitTime = globalSimClock;
            this.exitEntityID = entity.entityID;
            this.activity = "forward entity";
            this.endExitDisplayTime = globalSimClock + this.displayDelay;
            this.endAllDisplayTime = this.endExitDisplayTime;
            advance(this.displayDelay, this, "clearExitDisplay");
            displayProgressText("Combined comp. " + this.componentID + " forwards entity: " + this.exitEntityID + " at time " + globalSimClock.toFixed(6));

            this.countInProcessQueue--;
            this.queueToProcess();
            this.isOpen();
            this.nextComponentIndex = dest;
            this.savedDestination = -1;
            this.nextComponentList[dest].receiveEntity(entity);
            //record stats
            if (this.nextComponentList[dest].getComponentGroup() != entity.getComponentGroup()) {  //truly leaving a component group along the current connection
              recordGroupStatsWrapper(this.componentGroup, entity.getComponentGroupEntryTime(), entity);
            }
          }
        }
      };
      this.receiveEntity = function(entity) {  //CombinedComponent
        //receive the entity
        entity.setLocalEntryTime();  //record time entity entered queue
        if (entity.getComponentGroup() != this.componentGroup) {
          entity.setComponentGroup(this.componentGroup);
          entity.setComponentGroupEntryTime(globalSimClock);
          recordGroupStatsSystemEntryWrapper(this.componentGroup,entity);
        }
        entity.setForwardAttemptTime(Infinity);
        entity.setPermission(false);  //entity has reached end of related components group, permission no longer matters
        this.entityQueue.unshift(entity);
        this.countInQueue++;
        this.countInTraversal++;   //TODO: ensure handled properly if traversal time is zero
        this.isOpen();
        //display what was done
        this.entryTime = globalSimClock;
        this.entryEntityID = entity.entityID;
        this.activity = "receive entity";
        //set timer to clear the display after a bit
        this.endEntryDisplayTime = globalSimClock + this.displayDelay;
        this.endAllDisplayTime = this.endEntryDisplayTime;
        advance(this.displayDelay, this, "clearEntryDisplay");
        displayProgressText("Combined comp. " + this.componentID + " receives entity: " + this.entryEntityID + " at time " + globalSimClock.toFixed(6));
        if (this.traversalTime > 0) {
          //set timer for the new entity to track its traversal time
          advance(this.traversalTime, this, "traverseComplete");  //TODO: don't bother if traversal time is zero, also insure countInTraversal is decremented (or not incremented) as needed
        } else if (this.traversalTime == 0.0) {
          this.traverseComplete();
        }
      };
      this.activate = function(nextState) {
        if (nextState == "clearEntryDisplay") {
          this.clearEntryDisplay();
        } else if (nextState == "clearExitDisplay") {
          this.clearExitDisplay();
        } else if (nextState == "traverseComplete") {
          this.traverseComplete();
        } else if (nextState == "processComplete") {
          this.processComplete();
        } else {
          errorUndefinedAdvanceState(this.entityID, this.nextState);
        }
      };  //this.activate
    }  //CombinedComponent

    function assignEntityTypesSub(subEntity) {
      subEntity.setPropertyValue("Process Speed",subEntity.parentEntity.getPropertyValue("Process Speed"));
      subEntity.setPropertyValue("Residency",subEntity.parentEntity.getPropertyValue("Residency"));      
      subEntity.setPropertyValue("Base Type","Spawn");
      subEntity.setEntityColor("#FF8800");  //orange
    }  //assignEntityTypesSub
    
    //##default parameters##
    //function BagComponent(displayDelay, processTime, maxCapacity = 1, routingTable = [1.0]) {
    //function BagComponent(displayDelay, processTime) {
      //var maxCapacity = arguments.length > 1 && arguments[2] !== undefined ? arguments[2] : 1;
      //var routingTable = arguments.length > 2 && arguments[3] !== undefined ? arguments[3] : [1.0];
    //function BagComponent(processTime, processTimeSwitch, maxCapacity, routingTable) {
    function BagComponent(processTime, maxCapacity, displayCapacity, overCapacity, routingTable, spawnFlag, spawnArriveDelayTime, spawnDepartDelayTime) {
      if (typeof maxCapacity === "undefined") {maxCapacity = 1;}
      if (typeof displayCapacity === "undefined") {displayCapacity = 1;}
      if (typeof overCapacity === "undefined") {overCapacity = 1;}
      if (typeof routingTable === "undefined") {routingTable = [1.0];}
      if (typeof spawnFlag === "undefined") {spawnFlag = false;}
      if (typeof spawnArriveDelayTime === "undefined") {spawnArriveDelayTime = 0.0;}
      if (typeof spawnDepartDelayTime === "undefined") {spawnDepartDelayTime = 0.0;}
      //generally exclusive, should always be fed by a queue or at least "protected" by a status-based diversion component
      setOfComponents.push(this);
      this.componentID = getNewComponentID();
      this.componentType = "Bag";
      this.componentName = "Bag";
      this.componentGroup = "Bag";
      this.routingMethod = 1;  //1: one connection, 2: distribution, 3 routing
      this.previousComponentList = [];
      this.previousComponentCount = 0;
      this.nextComponentList = [];
      this.nextComponentCount = 0;
      this.nextComponentIDList = [];
      this.processTime = processTime;
      //this.processTimeSwitch = processTimeSwitch;
      this.maxCapacity = maxCapacity;
      this.overCapacity = overCapacity;
      if (this.maxCapacity < Infinity) {
        this.exclusive = true;
      } else {
        this.exclusive = false;
      }
      this.savedDestination = -1;
      this.previousComponentIndex = 0;
      this.nextComponentIndex = 0;
      this.entityQueue = [];
      this.subEntityQueue = [];
      for (var i=0; i<displayCapacity; i++) {  //TODO: should probably get this number from the number of XYLocs specified
        this.entityQueue[i] = null;
        this.subEntityQueue[i] = null;
      }
      this.exitQueue = [];
      this.routingTable = routingTable;
      this.openStatus = true;
      this.entryTime = "";
      this.entryEntityID = "";
      this.exitTime = "";
      this.exitEntityID = "";
      this.exitResidenceTime = "";
      this.countInBag = 0;
      this.countInProcess = 0;
      this.activity = "";
      this.endEntryDisplayTime = 0;
      this.endExitDisplayTime = 0;
      this.endAllDisplayTime = 0;
      this.displayDelay = 0;
      this.graphic = null;
      this.spawnFlag = spawnFlag;
      this.spawnArriveDelayTime = spawnArriveDelayTime;
      this.spawnDepartDelayTime = spawnDepartDelayTime;
      this.startSubComponent = null;  //TODO: verify that this is assigned if spawnFlag set to true
      this.returnSubComponent = null; //TODO: verify that this is assigned if spawnFlag set to true

      this.reset = function() {
        this.previousComponentIndex = this.previousComponentCount - 1;
        this.nextComponentIndex = this.nextComponentCount - 1;
        this.entityQueue = [];
        for (var i=0; i<displayCapacity; i++) {
          this.entityQueue[i] = null;
        }
        this.exitQueue = [];
        this.openStatus = true;
        this.savedDestination = -1;
        this.entryTime = "";
        this.entryEntityID = "";
        this.exitTime = "";
        this.exitEntityID = "";
        this.exitResidenceTime = "";
        this.countInBag = 0;
        this.countInProcess = 0;
        this.activity = "";
        this.endEntryDisplayTime = 0;
        this.endExitDisplayTime = 0;
        this.endAllDisplayTime = 0;
      };
      this.assignPreviousComponent = function(prev) {  //TODO-: implement code that makes this actually work
        this.previousComponentList.push(prev);
        this.previousComponentCount++;
        this.previousComponentIndex = this.previousComponentCount - 1;
        //TODO-: assign this automatically when upstream link and exclusive paths are required?
      };
      this.assignNextComponent = function(next) {  //BagComponent
        this.nextComponentList.push(next);
        this.nextComponentCount++;
        this.nextComponentIndex = this.nextComponentCount - 1;
        next.assignPreviousComponent(this);
        //TODO-: automatically assign upstream link if downstream component is exclusive?
      };
      this.assignStartSubJourneyComponent = function(startComp) {
        //next component must be non-exclusive, should be a StartSubJourneyComponent
        this.startSubComponent = startComp;  //TODO: verify that this is assigned if spawnFlag set to true
      };
      this.assignReturnFromSubJourneyComponent = function(returnComp) {
        this.returnSubComponent = returnComp; //TODO: verify that this is assigned if spawnFlag set to true
      };
      this.verifyLinks = function() {
        var i;
        var error = "";
        if (this.nextComponentCount > 0) {
          for (i = 0; i < this.nextComponentCount; i++) {  //>
            if (this.nextComponentList[i]) {  //link exists
              if (typeof this.nextComponentList[i] === "object") {  //link points to an object
                if ("componentType" in this.nextComponentList[i]) {  //object contains member componentType
                  if ((this.nextComponentList[i].componentType == "Arrivals") ||
                      (this.nextComponentList[i].componentType == "Entry")) {
                    error += this.componentType + " comp. " + this.componentID + " next comp. list element " + i + " is not an allowed comp.\n";
                  }
                } else {
                  //linked object does not contain member componentType
                  error += this.componentType + " comp. " + this.componentID + " next comp. list item " + i + " does not have componentType\n";
                }
              } else {
                //link points to something that is not an object
                error += this.componentType + " comp. " + this.componentID + " next comp. list item " + i + " is not an object\n";
              }
            } else {
              //link that should exist does not
              error += this.componentType + " comp. " + this.componentID + " next comp. list item " + i + " does not exist\n";
            }
          }
        } else {
          error += this.componentType + " comp. " + this.componentID + " has index of zero next components\n";
        }
        if (this.previousComponentCount > 0) {
          for (i = 0; i < this.previousComponentCount; i++) {  //>
            if (this.previousComponentList[i]) {  //link exists
              if (typeof this.previousComponentList[i] === "object") {  //link points to an object
                if ("componentType" in this.previousComponentList[i]) {  //object contains member componentType
                  if ((this.previousComponentList[i].componentType == "Arrivals") ||
                      (this.previousComponentList[i].componentType == "Exit")) {
                    error += this.componentType + " comp. " + this.componentID + " previous comp. list element " + i + " is not an allowed comp.\n";
                  }
                } else {
                  //linked object does not contain member componentType
                  error += this.componentType + " comp. " + this.componentID + " previous comp. list item " + i + " does not have componentType\n";
                }
              } else {
                //link points to something that is not an object
                error += this.componentType + " comp. " + this.componentID + " previous comp. list item " + i + " is not an object\n";
              }
            } else {
              //link that should exist does not
              error += this.componentType + " comp. " + this.componentID + " previous comp. list item " + i + " does not exist\n";
            }
          }
        } else {
          error += this.componentType + " comp. " + this.componentID + " has index of zero previous components\n";
        }
        return error;
      };

      this.getNextComponentIDs = function() {
        for (var i = 0; i < this.nextComponentCount; i++) {
          if (this.nextComponentList[i].getComponentType() != "Path") {
            this.nextComponentIDList[i] = this.nextComponentList[i].getComponentID();
          } else {
            this.nextComponentIDList[i] = this.nextComponentList[i].passComponentID();
          }
        }
      };

      this.getComponentID = function() {
        return this.componentID;
      };
      this.getComponentType = function() {  //BagComponent
        return this.componentType;
      };
      this.getComponentName = function() {
        return this.componentName;
      };
      this.setComponentName = function(componentName) {
        this.componentName = componentName;
      };
      this.getComponentGroup = function() {
        return this.componentGroup;
      };
      this.setComponentGroup = function(componentGroup) {
        this.componentGroup = componentGroup;
        addToGroupStatsNameListWrapper(componentGroup);
      };
      this.getExclusive = function() {
        return this.exclusive;
      };
      //this.setExclusive = function(exclusive) {
      //  this.exclusive = exclusive;
      //};
      this.getProcessTime = function() {
        return this.processTime;
      };
      //this.getProcessTimeSwitch = function() {
      //  return this.processTimeSwitch;
      //};
      //this.setProcessTimeSwitch = function(processTimeSwitch) {
      //  this.processTimeSwitch = processTimeSwitch;
      //};
      this.getMaxCapacity = function() {
        return this.maxCapacity;
      };
      this.setMaxCapacity = function(maxCapacity) {
        this.maxCapacity = maxCapacity;
      };
      this.getDisplayCapacity = function() {
        return this.displayCapacity;
      };
      this.getOverCapacity = function() {
        return this.overCapacity;
      };
      this.getOpenStatus = function() {
        return this.openStatus;
      };
      this.setOpenStatus = function(openStatus) {
        this.openStatus = openStatus;
      };
      this.getForwardAttemptTime = function() {
        if (this.exitQueue.length > 0) {
          return this.exitQueue[this.exitQueue.length - 1].getForwardAttemptTime();
        } else {
          return Infinity;
        }
      };
      this.getRoutingMethod = function() {
        return this.routingMethod;
      };
      this.setRoutingMethod = function(routingMethod) {
        this.routingMethod = routingMethod;
      };
      this.getEntryTime = function() {
        return this.entryTime;
      };
      this.getEntryEntityID = function() {
        return this.entryEntityID;
      };
      this.getExitTime = function() {
        return this.exitTime;
      };
      this.getExitEntityID = function() {
        return this.exitEntityID;
      };
      this.getExitResidenceTime = function() {
        return this.exitResidenceTime;
      };
      this.getCountInBag = function() {
        return this.countInBag;
      };
      this.getCountInProcess = function() {
        return this.countInProcess;
      };
      this.getActivity = function() {
        return this.activity;
      };
      this.getEndEntryDisplayTime = function() {
        return this.endEntryDisplayTime;
      };
      this.getEndExitDisplayTime = function() {
        return this.endExitDisplayTime;
      };
      this.getEndAllDisplayTime = function() {
        return this.endAllDisplayTime;
      };

      this.dataGroup = new DisplayGroup1();
      this.defineDataGroup = function(displayDelay, x, y, vw, bc, vc, lc) {
        this.displayDelay = displayDelay;
        this.dataGroup.define(this.componentID, this.componentType, x, y, vw, bc, vc, lc);
      };
      this.dataGroup.addValue(this.entryEntityID, "Entry ID", "integer");
      this.dataGroup.addValue(this.countInBag, "# In Bag", "numdec", "integer");
      this.dataGroup.addValue(this.exitEntityID, "Exit ID", "integer");
      this.dataGroup.addValue(this.exitResidenceTime, "Resdnce Tm", "numdec", 5);
      this.dataGroup.addValue(this.activity, "Activity", "text");

      this.assignDisplayValues = function() {
        this.dataGroup.valueList[0].value = this.entryEntityID;
        this.dataGroup.valueList[1].value = this.countInBag;
        this.dataGroup.valueList[2].value = this.exitEntityID;
        this.dataGroup.valueList[3].value = this.exitResidenceTime;
        this.dataGroup.valueList[4].value = this.activity;
        if (this.exclusive) {
          if (this.openStatus) {
            this.dataGroup.setBorderColor("#00FF00");
          } else {
            this.dataGroup.setBorderColor("#FF0000");
          }
        }
      };
      this.drawData = function() {  //BagComponent
        this.assignDisplayValues();
        this.dataGroup.drawBasic();
      };

      this.defineGraphic = function(graphic) {
        this.graphic = graphic;
      };
      this.updateGraphic = function() {
        this.graphic.setTraverseValue(this.countInProcess);
        this.graphic.setCountValue(this.countInBag);
      };

      this.isOpen = function() {  //BagComponent
        if (this.exclusive) {
          if (this.currentCount() < this.maxCapacity + this.overCapacity) {
            this.openStatus = true;
          } else {
            this.openStatus = false;
          }
          for (var i = 0; i < this.previousComponentCount; i++) {
            if (this.previousComponentList[i].getComponentType() == "Path") {
              this.previousComponentList[i].setPreviousStatus(this.openStatus);  //this may only be needed to determine open/closed status for display, count <=> capacity used when something is trying to enter
            }
          }
        }
        return this.openStatus;  //if not exclusive should be set to true by default
      };
      this.clearEntryDisplay = function() {
        //only clear display if a new one hasn't started a new timer
        if (globalSimClock >= this.endEntryDisplayTime) {
          this.entryTime = "";
          this.entryEntityID = "";
        }
        if (globalSimClock >= this.endAllDisplayTime) {
          this.activity = "";
        }
        //displayProgressText("Bag entry "+this.componentID+" clears at time "+globalSimClock.toFixed(6));
      };
      this.clearExitDisplay = function() {
        //only clear display if a new one hasn't started a new timer
        if (globalSimClock >= this.endExitDisplayTime) {
          this.exitTime = "";
          this.exitEntityID = "";
          this.exitResidenceTime = "";
        }
        if (globalSimClock >= this.endAllDisplayTime) {
          this.activity = "";
        }
        //displayProgressText("Bag exit "+this.componentID+" clears at time "+globalSimClock.toFixed(6));
      };
      this.currentCount = function() {
        var count = 0;
        if (this.exclusive) {
          //start with entities already in component
          count = this.countInBag;
          //add entities in feeding paths
          for (var i = 0; i < this.previousComponentCount; i++) {
            if (this.previousComponentList[i].componentType == "Path") {  //TODO- consider adding test for whether path is boundary component for associated exclusive group of components //do this using no-time/no-space control component to define boundary
              count += this.previousComponentList[i].currentCount();
            }
          }
        }
        return count;
      };
      this.pullFromPrevious = function() {  //BagComponent
        var oldest = this.previousComponentList[0].getForwardAttemptTime();
        var oldestIndex = 0;
        for (var i = 1; i < this.previousComponentCount; i++) {
          var age = this.previousComponentList[i].getForwardAttemptTime();
          if (age < oldest) {
            oldestIndex = i;
          }
        }
        if (this.previousComponentList[oldestIndex].getComponentType() != "Path") {
          if (this.previousComponentList[oldestIndex].getComponentType() != "Entry") {
            //TODO: this should call forward entity in a way that ensures that previous component only sends entity to where it is requested and if one is available and if this is a legitimate destination
            this.previousComponentList[oldestIndex].forwardEntity(this.componentID);
          }
        } else {
          displayProgressText("Bag comp. " + this.componentID + " pulls from previous (" + oldestIndex + ") at time " + globalSimClock.toFixed(6));
          this.previousComponentList[oldestIndex].pullFromPrevious(this.componentID);
        }
      };
      this.nextOpen = function() {
        var startIndex = this.nextComponentIndex;
        var tempIndex = startIndex;
        do {
          tempIndex++;
          if (tempIndex >= this.nextComponentCount) {
            tempIndex = 0;
          }
          if (this.nextComponentList[tempIndex].isOpen()) {
            //open link found, update and return nextComponentIndex
            return tempIndex;
          }
        } while (tempIndex != startIndex);
        return -1;  //no open links found, leave nextComponentIndex unchanged
      };
      this.processComplete = function(entity) {  //BagComponent
        this.countInProcess--;   //TODO: ensure handled properly if process time is zero //prob. not applicable
        //figure out which entity just finished processing
        var tempID = entity.entityID;
        this.exitQueue.unshift(entity);
        this.entityQueue[entity.getLocalIndex()] = null;
        entity.setForwardAttemptTime(globalSimClock);
        displayProgressText("Bag comp. " + this.componentID + " entity: " + tempID + " processed at " + globalSimClock.toFixed(6));
        this.forwardEntity();  //try to forward it  //TODO: check to see if this should NOT be called?
      };
      this.startSubJourney = function(subEntity) {
        this.startSubComponent.receiveEntity(subEntity);
        this.subEntityQueue[subEntity.parentEntity.getLocalIndex()] = null;
      };
      this.continueFromSubJourney = function(subEntity) {
        this.subEntityQueue[subEntity.parentEntity.getLocalIndex()] = null;
        this.processComplete(subEntity.parentEntity);
        removeEntityFromList(subEntity.getEntityID());  //be sure to destroy the subEntity      
      };
      this.returnFromSubJourney = function(subEntity) {
        this.subEntityQueue[subEntity.parentEntity.getLocalIndex()] = subEntity;
        if (this.spawnDepartDelayTime > 0.0) {
          advance(this.spawnDepartDelayTime, this, "endSubDepartDelay", subEntity);
        } else {
          this.continueFromSubJourney(subEntity);
        }
      };
      //##default parameters##
      //this.forwardEntity = function(destIndex = -1) {  //BagComponent
      //this.forwardEntity = function() {  //BagComponent
        ///var routingTable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
      this.forwardEntity = function(destIndex) {  //BagComponent
        if (typeof destIndex === "undefined") {destIndex = -1;}
        var dest = -1;
        if (destIndex >= 0) {  //pull request from a specific downstream component, must send entity there
          if (this.routingMethod == 1) { //single connection, nothing to do
            dest = 0;
          } else if (this.routingMethod == 2) { //distribution, send to any request
            dest = 0;
            while ((this.nextComponentIDList[dest] != destIndex) && (dest < this.nextComponentCount)) {  //second test should not be needed, loop can't fail to return valid result
              dest++;
            }
          } else if (this.routingMethod == 3) {  //model routing logic, TODO: don't forward if not desired destination
            dest = 0;
            while ((this.nextComponentIDList[dest] != destIndex) && (dest < this.nextComponentCount)) {  //second test should not be needed, loop can't fail to return valid result
              dest++;
            }
          }
          dummy2 = 0;
        } else {
          if (this.routingMethod == 1) {  //single connection
            if (this.nextComponentList[0].isOpen()) {
              dest = 0;
            }
          } else if (this.routingMethod == 2) {  //distribution
            var nextIndex = this.nextOpen();
            if (nextIndex >= 0) {
              dest = nextIndex;
              //this.nextComponentIndex = dest;
            }
          } else if (this.routingMethod == 3) {  //model routing logic
            if (this.savedDestination >= 0) {
              dest = this.savedDestination;
            } else {
              dest = 0;
              var test = Math.random();
              //need access to entity type but can't pop it off queue here
              var index = this.countInQueue - 1;
              if (index >= 0) {
                index = entityDiversionPercentIndex(this.entityQueue[index]);  //get head item in queue and find out what type it is
              } else {
                index = 0;  //nothing in queue, following code will work but nothing will be popped and processed below
              }
              while (test > this.routingTable[index][dest]) {
                dest++;
              }
              if (dest <= this.nextComponentCount) {
                if (!this.nextComponentList[dest].isOpen()) {
                  dest = -1;
                }
              } else {
                alert("Bag comp. tried to assign destination with too high of an index")
              }
              if (dest >= 0) {
                this.savedDestination = dest;  //ensure that once destination is determined for this entity that we don't keep changing it
              }
            }
          } else {  //0 uninitialized or anything else
            alert("comp. " + this.componentID + " incorrect routing method: " + this.routingMethod);
          }
        }
        if (dest >= 0) {
          if (this.countInBag > this.countInProcess) {
            var entity = this.exitQueue.pop();  //TODO-: are we testing to ensure the next entity is really available
            if (entity) {  //TODO-: since we've tested above this should not be necessary
              //calculate how long item was in process
              this.exitResidenceTime = globalSimClock - entity.getLocalEntryTime();
              this.exitTime = globalSimClock;
              this.exitEntityID = entity.entityID;
              this.activity = "forward entity";
              this.endExitDisplayTime = globalSimClock + this.displayDelay;
              this.endAllDisplayTime = this.endExitDisplayTime;
              advance(this.displayDelay, this, "clearExitDisplay");
              displayProgressText("Bag comp. " + this.componentID + " forwards entity: " + this.exitEntityID + " at time " + globalSimClock.toFixed(6));

              this.countInBag--;
              //should be open now
              if (this.exclusive) {
                displayProgressText("Bag comp. " + this.componentID + " calls pull from previous at time " + globalSimClock.toFixed(6));
                if (!this.openStatus) {
                  this.pullFromPrevious(); //TODO: call this with a modest (~1 sec) delay to account for reaction time? //may or may not successfully get an entity but should always be called
                }
              }
              this.isOpen();
              this.nextComponentIndex = dest;
              this.savedDestination = -1;  //clear old choice when entity successfully forwarded
              this.nextComponentList[dest].receiveEntity(entity);
              //record stats
              if (this.nextComponentList[dest].getComponentGroup() != entity.getComponentGroup()) {  //truly leaving a component group along the current connection
                recordGroupStatsWrapper(this.componentGroup, entity.getComponentGroupEntryTime(), entity);
              }
            }
          }
        }
      };
      this.receiveEntity = function(entity) {  //BagComponent
        //receive the entity
        entity.setLocalEntryTime();  //record time entity entered bag
        if (entity.getComponentGroup() != this.componentGroup) {
          entity.setComponentGroup(this.componentGroup);
          entity.setComponentGroupEntryTime(globalSimClock);
          recordGroupStatsSystemEntryWrapper(this.componentGroup,entity);
        }
        //figure out which parking space to use
        var i = 0;
        while (this.entityQueue[i] != null) {
          i++;
        }
        if (i < this.maxCapacity) {
          this.entityQueue[i] = entity;
          entity.setLocalIndex(i);
        } else {  //this shouldn't happen
          alert("Bag comp. "+this.componentID+" over capacity at time "+this.globalSimClock.toFixed(6));
        }
        entity.setForwardAttemptTime(Infinity);  //TODO: figure out how to handle this
        entity.setPermission(false);  //entity has reached end of related components group, permission no longer matters
        this.countInProcess++;
        this.countInBag++;  //TODO: handle if process time is zero?
        this.isOpen();
        //display what was done
        this.entryTime = globalSimClock;
        this.entryEntityID = entity.entityID;
        this.activity = "receive entity";
        //set timer to clear the display after a bit
        this.endEntryDisplayTime = globalSimClock + this.displayDelay;
        this.endAllDisplayTime = this.endEntryDisplayTime;
        advance(this.displayDelay, this, "clearEntryDisplay");
        //set timer for the process duration
//        var pTime = this.processTime[entityProcessTimeIndex(entity,this.processTimeSwitch)];
        if (!this.spawnFlag) {
          var pTime = processTime(entity);
          advance(pTime, this, "processComplete",entity);
        } else {  //spawn subordinate entity
          var subEntity = generateNewEntity(entity);  //reference to parent entity
          assignEntityTypesSub(subEntity);
          this.subEntityQueue[i] = subEntity;
          recordGroupStatsSystemEntryWrapper("SubSystem",subEntity);
          if (this.spawnArriveDelayTime > 0.0) {
            advance(this.spawnArriveDelayTime, this, "endSubArriveDelay", subEntity);
          } else {
            this.startSubJourney(subEntity);
          }
        }
        displayProgressText("Bag comp. " + this.componentID + " receives entity: " + this.entryEntityID + " at time " + globalSimClock.toFixed(6));
      };
      this.activate = function(nextState, entity2) {
        if (nextState == "clearEntryDisplay") {
          this.clearEntryDisplay();
        } else if (nextState == "clearExitDisplay") {
          this.clearExitDisplay();
        } else if (nextState == "processComplete") {
          this.processComplete(entity2);
        } else if (nextState == "endSubArriveDelay") {
          this.startSubJourney(entity2);
        } else if (nextState == "endSubDepartDelay") {
          this.continueFromSubJourney(entity2);
        } else {
          errorUndefinedAdvanceState(this.entityID, this.nextState);
        }
      };  //this.activate

    }  //BagComponent
    
    function ExitComponent() {
      setOfComponents.push(this);
      this.componentID = getNewComponentID();
      this.componentType = "Exit";
      this.componentName = "Exit";
      this.componentGroup = "Exit";
      this.exclusive = false;
      this.previousComponentList = [];
      this.previousComponentCount = 0;
      this.maxCapacity = Infinity;
      this.openStatus = true;
      this.exitTime = "";
      this.exitEntityID = "";
      this.exitResidenceTime = "";
      this.activity = "";
      this.exitCount = 0;
      this.endExitDisplayTime = 0;
      this.displayDelay = 0;
      this.graphic = null;

      this.reset = function() {
        this.openStatus = true;
        this.exitTime = "";
        this.exitEntityID = "";
        this.exitResidenceTime = "";
        this.activity = "";
        this.exitCount = 0;
        this.endExitDisplayTime = 0;
      };
      this.assignPreviousComponent = function(prev) {  //TODO-: implement code that makes this actually work
        this.previousComponentList.push(prev);
        this.previousComponentCount++;
        this.previousComponentIndex = this.previousComponentCount - 1;
      };
      this.verifyLinks = function() {
        var error = "";
        if (this.previousComponentCount > 0) {
          for (var i = 0; i < this.previousComponentCount; i++) {  //>
            if (this.previousComponentList[i]) {  //link exists
              if (typeof this.previousComponentList[i] === "object") {  //link points to an object
                if ("componentType" in this.previousComponentList[i]) {  //object contains member componentType
                  if ((this.previousComponentList[i].componentType == "Arrivals") ||
                      (this.previousComponentList[i].componentType == "Entry") ||
                      (this.previousComponentList[i].componentType == "Exit")) {
                    error += this.componentType + " comp. " + this.componentID + " previous comp. list element " + i + " is not an allowed comp.\n";
                  }
                } else {
                  //linked object does not contain member componentType
                  error += this.componentType + " comp. " + this.componentID + " previous comp. list item " + i + " does not have componentType\n";
                }
              } else {
                //link points to something that is not an object
                error += this.componentType + " comp. " + this.componentID + " previous comp. list item " + i + " is not an object\n";
              }
            } else {
              //link that should exist does not
              error += this.componentType + " comp. " + this.componentID + " previous comp. list item " + i + " does not exist\n";
            }
          }
        } else {
          error += this.componentType + " comp. " + this.componentID + " has index of zero previous components\n";
        }
        return error;
      };

      this.getComponentID = function() {
        return this.componentID;
      };
      this.getComponentType = function() {  //ExitComponent
        return this.componentType;
      };
      this.getComponentName = function() {
        return this.componentName;
      };
      this.setComponentName = function(componentName) {
        this.componentName = componentName;
      };
      this.getComponentGroup = function() {
        return this.componentGroup;
      };
      this.setComponentGroup = function(componentGroup) {
        this.componentGroup = componentGroup;
        addToGroupStatsNameListWrapper(componentGroup);
      };
      this.getExclusive = function() {
        return this.exclusive;
      };
      //this.setExclusive = function(exclusive) {
      //  this.exclusive = exclusive;
      //};
      this.getOpenStatus = function() {
        return this.openStatus;
      };
      this.setOpenStatus = function(openStatus) {
        this.openStatus = openStatus;
      };
      this.getActivity = function() {
        return this.activity;
      };
      this.getExitCount = function() {
        return this.exitCount;
      };
      this.getEndExitDisplayTime = function() {
        return this.endExitDisplayTime;
      };

      this.dataGroup = new DisplayGroup1();
      this.defineDataGroup = function(displayDelay, x, y, vw, bc, vc, lc) {
        this.displayDelay = displayDelay;
        this.dataGroup.define(this.componentID, this.componentType, x, y, vw, bc, vc, lc);
      };
      this.dataGroup.addValue(this.exitEntityID, "Exit ID", "integer");
      this.dataGroup.addValue(this.exitResidenceTime, "Resdnce Tm", "numdec", 5);
      this.dataGroup.addValue(this.activity, "Activity", "text");
      this.dataGroup.addValue(this.entryCount, "Exit Count", "text");

      this.assignDisplayValues = function() {
        this.dataGroup.valueList[0].value = this.exitEntityID;
        this.dataGroup.valueList[1].value = this.exitResidenceTime;
        this.dataGroup.valueList[2].value = this.activity;
        this.dataGroup.valueList[3].value = this.exitCount;
      };
      this.drawData = function() {
        this.assignDisplayValues();
        this.dataGroup.drawBasic();
      };

      this.defineGraphic = function(graphic) {
        this.graphic = graphic;
      };
      this.updateGraphic = function() {
        //do nothing
      };

      this.isOpen = function() {  //ExitComponent
        return this.openStatus;
      };
      this.clearExitDisplay = function() {
        if (globalSimClock >= this.endExitDisplayTime) {
          this.exitTime = "";
          this.exitEntityID = "";
          this.exitResidenceTime = "";
          this.activity = "";
        }
        //displayProgressText("Exit comp. "+this.componentID+" clears at time "+globalSimClock.toFixed(6));
      };
      this.pullFromPrevious = function() {  //ExitComponent  //TODO-: this is OK if we assume Exit components are always open, in which case this should never be called
        //should never be called
        displayProgressText("Exit comp. " + this.componentID + " pulls from previous at time " + globalSimClock.toFixed(6));
        this.previousComponent.forwardEntity();
      };
      this.receiveEntity = function(entity) {  //ExitComponent
        //receive the entity
        this.exitResidenceTime = globalSimClock - entity.getEntryTime();
        recordGroupStatsWrapper("System", entity.getEntryTime(), entity);
        //display what was done
        this.exitTime = globalSimClock;
        this.exitEntityID = entity.entityID;
        this.activity = "entity exits";
        //set timer to clear the display after a bit
        this.endExitDisplayTime = globalSimClock + this.displayDelay;
        this.exitCount++;
        advance(this.displayDelay, this, "clearExitDisplay");
        displayProgressText("Exit comp. " + this.componentID + " receives entity: " + this.exitEntityID + " at time " + globalSimClock.toFixed(6));
        removeEntityFromList(entity.entityID);
      };
      this.activate = function(nextState) {
        if (nextState == "clearExitDisplay") {
          this.clearExitDisplay();
        } else {
          errorUndefinedAdvanceState(this.entityID, this.nextState);
        }
      };  //this.activate
    }  //ExitComponent

    var globalDefaultSpeed = 20.0;
    var globalDefaultMovementInterval = 1.0;
    
    function PathComponent(speed, maxRefreshTime) {
      if (typeof speed === "undefined") {speed = globalDefaultSpeed;}
      if (typeof maxRefreshTime === "undefined") {maxRefreshTime = globalDefaultMovementInterval;}
      setOfComponents.push(this);
      this.componentID = getNewComponentID();
      this.componentType = "Path";
      this.componentName = "Path";
      this.componentGroup = "Path";
      this.exclusive = false;
      this.previousComponent = null;
      this.nextComponent = null;
      this.maxCapacity = Infinity;
      this.entityQueue = [];
      this.traverseQueue = [];
      this.openStatus = true;
      this.entryTime = "";
      this.entryEntityID = "";
      this.exitTime = "";
      this.exitEntityID = "";
      this.exitResidenceTime = "";  //TODO: probably not needed
      this.countInQueue = 0;
      this.x1 = 0.0;
      this.y1 = 0.0;
      this.x2 = 0.0;
      this.y2 = 0.0;
      this.pathLength = 0.0;
      //this.endTraverse = 0.0;
      this.speed = speed;
      this.maxRefreshTime = maxRefreshTime;
      this.graphic = null;

      this.reset = function() {
        this.entityQueue = [];
        this.traverseQueue = [];
        this.openStatus = true;
        this.entryTime = "";
        this.entryEntityID = "";
        this.exitTime = "";
        this.exitEntityID = "";
        this.exitResidenceTime = "";  //TODO: probably not needed
        this.countInQueue = 0;
        //this.endTraverse = 0.0;
      };
      this.assignPreviousComponent = function(previous) {
        this.previousComponent = previous;
      };
      this.assignNextComponent = function(next) {  //PathComponent
        this.nextComponent = next;
        this.exclusive = next.getExclusive();
        next.assignPreviousComponent(this);
      };
      this.getNextExclusive = function() {
        if (this.nextComponent.getComponentType() != "Path") {
          return this.nextComponent.getExclusive();
        } else {
          return this.nextComponent.getNextExclusive();
        }
      };
      this.verifyLinks = function() {
        var error = "";
        if (this.nextComponent) {  //link exists
          if (typeof this.nextComponent === "object") {  //link points to an object
            if ("componentType" in this.nextComponent) {  //object contains member componentType
              if ((this.nextComponent.componentType == "Arrivals") ||
                  (this.nextComponent.componentType == "Entry")) {
                error += this.componentType + " comp. " + this.componentID + " next comp. is not an allowed comp.\n";
              }
            } else {
              //linked object does not contain member componentType
              error += this.componentType + " comp. " + this.componentID + " next comp. does not have componentType\n";
            }
          } else {
            //link points to something that is not an object
            error += this.componentType + " comp. " + this.componentID + " next comp. is not an object\n";
          }
        } else {
          //link that should exist does not
          error += this.componentType + " comp. " + this.componentID + " next comp. does not exist\n";
        }
        if (this.previousComponent) {  //link exists
          if (typeof this.previousComponent === "object") {  //link points to an object
            if ("componentType" in this.previousComponent) {  //object contains member componentType
              if ((this.previousComponent.componentType == "Arrivals") ||
                  (this.previousComponent.componentType == "Exit")) {
                error += this.componentType + " comp. " + this.componentID + " previous comp. is not an allowed comp.\n";
              }
            } else {
              //linked object does not contain member componentType
              error += this.componentType + " comp. " + this.componentID + " previous comp. does not have componentType\n";
            }
          } else {
            //link points to something that is not an object
            error += this.componentType + " comp. " + this.componentID + " previous comp. is not an object\n";
          }
        } else {
          //link that should exist does not
          error += this.componentType + " comp. " + this.componentID + " previous comp. does not exist\n";
        }
        return error;
      };

//      this.setStartPoint = function(x1, y1) {
//        this.x1 = x1;
//        this.y1 = y1;
//      };
//      this.getStartPoint = function() {
//        return {x: this.x1, y: this.y1};
//      };
//      this.setEndPoint = function(x2, y2) {
//        this.x2 = x2;
//        this.y2 = y2;
//      };
//      this.getEndPoint = function() {
//        return {x: this.x2, y: this.y2};
//      };
      this.setSpeedTime = function(speed, maxRefreshTime) {
        this.speed = speed;
        this.maxRefreshTime = maxRefreshTime;
      };
      this.calcPathLength = function() {
        //ignore node locations for connecting components, use locations from graphic component
        var location = this.graphic.getInNode();
        this.x1 = location.x;
        this.y1 = location.y;
        location = this.graphic.getOutNode();
        this.x2 = location.x;
        this.y2 = location.y;
        this.pathLength = Math.sqrt((this.x2 - this.x1) * (this.x2 - this.x1) +
            (this.y2 - this.y1) * (this.y2 - this.y1));
        //this.endTraverse = this.pathLength;
      };

      this.getComponentID = function() {
        return this.componentID;
      };
      this.passComponentID = function() {
        if (this.nextComponent.getComponentType() != "Path") {
          return this.nextComponent.getComponentID();
        } else {
          return this.nextComponent.passComponentID();
        }
      };
      this.getComponentType = function() {  //PathComponent
        return this.componentType;
      };
      this.getComponentName = function() {
        return this.componentName;
      };
      this.setComponentName = function(componentName) {
        this.componentName = componentName;
      };
      this.getComponentGroup = function() {
        //return this.componentGroup;
        return this.nextComponent.getComponentGroup();
      };
      this.setComponentGroup = function(componentGroup) {
        this.componentGroup = componentGroup;
        addToGroupStatsNameListWrapper(componentGroup);
      };
      this.getExclusive = function() {
        return this.exclusive;
      };
      this.setExclusive = function(exclusive) {
        this.exclusive = exclusive;
      };
      this.getMaxCapacity = function() {
        return this.maxCapacity;
      };
      this.setMaxCapacity = function(maxCapacity) {
        this.maxCapacity = maxCapacity;
      };
      this.getOpenStatus = function() {
        return this.openStatus;
      };
      this.setOpenStatus = function(openStatus) {
        this.openStatus = openStatus;
      };
      this.getEntryTime = function() {
        return this.entryTime;
      };
      this.getEntryEntityID = function() {
        return this.entryEntityID;
      };
      this.getExitTime = function() {
        return this.exitTime;
      };
      this.getExitEntityID = function() {
        return this.exitEntityID;
      };
      this.getExitResidenceTime = function() {
        return this.exitResidenceTime;
      };
      this.getCountInQueue = function() {
        return this.countInQueue;
      };

      this.drawData = function() {
        if (this.exclusive) {
          if (this.openStatus) {
            this.lineColor = "#00FF00";
          } else {
            this.lineColor = "#FF0000";
          }
        } else {
          this.lineColor = "#FFFFFF";
        }
        globalCTX.strokeStyle = this.lineColor;
        globalCTX.beginPath();
        globalCTX.moveTo(this.x1 + 0.5, this.y1 + 0.5);
        globalCTX.lineTo(this.x2 + 0.5, this.y2 + 0.5);
        globalCTX.stroke();
      };

      this.defineGraphic = function(graphic) {
        this.graphic = graphic;
      };
      this.updateGraphic = function() {
        //do nothing
      };

      this.isOpen = function() {  //PathComponent
        this.openStatus = true;
        if (!this.exclusive) {
          if (this.entityQueue.length > 0) {
            if (this.traverseQueue[0] < (10 + 2)) {
              if (this.previousComponent.componentType == "Path") {
                this.openStatus = false;
              }
            }   //find a way to set path to open once entity moves far enough, also if path < 10+2 long
          }
        } else {
          this.openStatus = this.nextComponent.isOpen();
        }
        return this.openStatus;
      };
      this.currentCount = function() {
        var count = 0;
        if (this.exclusive) {
          //start with entities already in component
          count = this.countInQueue;
          //add entities in feeding paths
          if (this.previousComponent.getComponentType() == "Path") {  //TODO: consider adding test for whether path is boundary component for associated exclusive group of components //do this using no-time/no-space component to define boundary
            count += this.previousComponent.currentCount();
          }
        }
        return count;
      };
      this.getForwardAttemptTime = function() {
        return this.previousComponent.getForwardAttemptTime();
      };
      //##default parameters##
      //this.pullFromPrevious = function(destIndex = -1) {  //PathComponent
      //this.pullFromPrevious = function() {  //PathComponent
        //var destIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
      this.pullFromPrevious = function(destIndex) {  //PathComponent
        if (typeof destIndex === "undefined") {destIndex = -1;}
        if (this.previousComponent.getComponentType() != "Path") {  //TODO: figure out what, if anything, happens when need to support multiple incoming/previous links
          if (this.previousComponent.getComponentType() != "Entry") {
            displayProgressText("Path comp. " + this.componentID + " pulls from previous (fwd) at time " + globalSimClock.toFixed(6));
            this.previousComponent.forwardEntity(destIndex);
          }
        } else {
          displayProgressText("Path comp. " + this.componentID + " calls pull from previous at time " + globalSimClock.toFixed(6));
          this.previousComponent.pullFromPrevious(destIndex);
        }
      };
      //this.setNextClosed = function() {
      //  this.openStatus = false;
      //  if (this.nextComponent.getComponentType() != "Path") {
      //    this.nextComponent.setOpenStatus(false);
      //  } else {
      //    this.nextComponent.setNextClosed();
      //  }
      //};
      this.setPreviousStatus = function(openStatus) {
        this.openStatus = openStatus;
        if (this.previousComponent.getComponentType() == "Path") {
          this.previousComponent.setPreviousStatus(openStatus);
        }
      };
      this.moveEntity = function(entity) {  //PathComponent
        //moves entities down path, but keeps them from overlapping
        //for now assumes radius of 5 and clearance of 2
        //start from discharge end of list
        var index = this.entityQueue.length - 1;
        if (index < 0) {
          dummy2 = 0;
        }
        while ((this.entityQueue[index].entityID != entity.entityID) && (index > 0)) {
          index--;
        }
        var distanceIncrement = this.speed * this.maxRefreshTime;
        var dist = distanceIncrement;
        var timeIncrement = this.maxRefreshTime;
        var nextState = "move";
        if (index < this.entityQueue.length - 1) {
          //not the lead entity, check against next entity
          if (this.traverseQueue[index] + distanceIncrement > (this.traverseQueue[index + 1] - 10 - 2)) {
            dist = this.traverseQueue[index + 1] - 10 - 2 - this.traverseQueue[index];
            if (dist <= 0.0) {
              dist = 0.0;
              timeIncrement = this.maxRefreshTime; //0.5;
            } else {
              timeIncrement *= dist / distanceIncrement;
            }
          }
        } else {
          //this is the lead entity, check against end of path  //really need to check against clearance considering entities on next path if applicable
          if (this.traverseQueue[index] + distanceIncrement > this.pathLength) {
            dist = this.pathLength - this.traverseQueue[index] + 0.001;
            timeIncrement *= dist / distanceIncrement;
            nextState = "forward";  //what if item isn't actually forwarded?  event would get lost...
          }
        }
        this.traverseQueue[index] += dist; //distanceIncrement;
        var frac = this.traverseQueue[index] / this.pathLength;
        var x = this.x1 + (this.x2 - this.x1) * frac;
        var y = this.y1 + (this.y2 - this.y1) * frac;
        entity.setLocation(x, y);
        if ((index == 0) && (!this.exclusive)) {
          if (this.traverseQueue[index] >= (10 + 2)) {
            this.openStatus = true;  //pullFromPrevious here?  would depend on exclusivity
            if (this.previousComponent.componentType == "Path") {
              if (this.previousComponent.countInQueue > 0) {
                if (this.previousComponent.traverseQueue[this.previousComponent.countInQueue - 1] > this.previousComponent.pathLength) {
                  this.previousComponent.forwardEntity();
                }
              }
            }
          }
        }
        advance(timeIncrement, this, nextState, entity);
        displayProgressText("Path comp. " + this.componentID + " moves entity " + entity.entityID + " at time " + globalSimClock.toFixed(6));
      };
      this.forwardEntity = function() {  //PathComponent
        if (this.countInQueue > 0) {
          if (this.nextComponent.isOpen() || this.entityQueue[this.countInQueue - 1].getPermission()) {
            var testDist = this.traverseQueue.pop();
            var entity = this.entityQueue.pop();
            //if (entity) { //test for presence of entity obviates this test
            //TODO: probably also need to test to see if entity is at end of Path to prevent pulling forward when entity has not reached the end
            if (testDist < this.pathLength) {
              displayProgressText("Path comp. " + this.componentID + " pulled entity " + entity.entityID + " before end of path at time " + globalSimClock.toFixed(6));
              dummy2 = 1;
            }
            this.countInQueue--;
            if (this.countInQueue != this.entityQueue.length) {
              dummy2 = 0;
            }
            //TODO: in theory there should be no need to call isOpen here because the entity would still be within the relevant system
            this.exitTime = globalSimClock;
            this.exitEntityID = entity.entityID;
            displayProgressText("Path comp. " + this.componentID + " forwards entity: " + this.exitEntityID + " at time " + globalSimClock.toFixed(6));
            this.nextComponent.receiveEntity(entity);
            //}
          }
        }
      };
      this.receiveEntity = function(entity) {  //PathComponent
        //receive the entity
        entity.setLocalEntryTime();  //record time entity entered queue
        if (this.exclusive) {
          entity.setPermission(true);
        }
        entity.setLocation(this.x1, this.y1);
        advance(this.maxRefreshTime, this, "move", entity);
        this.traverseQueue.unshift(0.0);
        this.entityQueue.unshift(entity);
        this.countInQueue++;
        //display what was done
        this.entryTime = globalSimClock;
        this.entryEntityID = entity.entityID;
        displayProgressText("Path comp. " + this.componentID + " receives entity: " + this.entryEntityID + " at time " + globalSimClock.toFixed(6));
        if (this.exclusive) {  //TODO: see if this works without the test
          this.isOpen();
        }
      };
      this.activate = function(nextState, entity2) {
        if (nextState == "move") {
          this.moveEntity(entity2);
        } else if (nextState == "forward") {
          this.forwardEntity();
        } else {
          errorUndefinedAdvanceState(this.entityID, this.nextState);
        }
      };  //this.activate
    }  //PathComponent

    function displayEndMessage() {
      globalCTX.font = "12px Arial";
      globalCTX.fillStyle = "#FF00FF";
      globalCTX.textAlign = "left";
      globalCTX.fillText("Simulation has ended", 10.0, canvas.height - 2);
      if (globalSimClock > (statsTimeIndex * statsUpdateInterval)) {        
        incrementStatsTimeIndexWrapper();
      }
      if (!fullScreen3D) {
        reportStatsWrapper();
      }
    }  //displayEndMessage

//////////////////////////////////
    //schedule for seven hours of arrivals in half-hour blocks
    var arrivalSchedule = [0, 1, 2, 6, 7, 7, 8, 9, 7, 6, 4, 2, 1, 0];
    var entryDistribution = [[1.0], [1.0], [1.0], [1.0], [1.0], [1.0], [1.0], [1.0], [1.0], [1.0], [1.0], [1.0], [1.0], [1.0]];

    var arrival1 = new ArrivalsComponent(30.0, arrivalSchedule, entryDistribution);
    //arrival1.defineDataGroup(2.0, 61, 2, 70, globalNeutralColor, globalValueColor, globalLabelColor);  //leave in place
    var tempGraphic;

    var routingTable = [[1.0],[1.0],[1.0]];
    var entry1 = new EntryComponent(routingTable);
    entry1.setRoutingMethod(3);  //1 single connection, 2 distribution logic, 3 model logic
    entry1.setComponentName("Entry1");
    
    tempGraphic = new DisplayElement(entry1, 210, 5, 68, 20);
    //tempGraphic = new DisplayElement(entry1, 210, 5, 68, 20, 0.0, false, false, []);

    arrival1.assignNextComponent(entry1);

    var pathE1Q0A = new PathComponent(10.0);
    tempGraphic = new DisplayElement(pathE1Q0A, 0, 0, 260, 37);

    entry1.assignNextComponent(pathE1Q0A);

    var pathE1Q0B = new PathComponent(10.0);
    tempGraphic = new DisplayElement(pathE1Q0B, 260, 37, 0, 0);

    var routingTableQ0 = [[1.0],[1.0],[1.0]];  //not actually needed since routingMethod is 2 here
    var queue0 = new QueueComponent(0.0, Infinity, routingTableQ0);
    queue0.setRoutingMethod(2);  //1 single connection, 2 distribution logic, 3 model logic
    queue0.setComponentName("Q0");
    queue0.setComponentGroup("Primary");

    tempGraphic = new DisplayElement(queue0, 200, 50, 88, 56);
    var tgBaseY = 25;  //49;
    tempGraphic.addXYLoc(0, 44, tgBaseY + 24);
    tempGraphic.addXYLoc(0, 32, tgBaseY + 24);
    tempGraphic.addXYLoc(0, 20, tgBaseY + 24);
    tempGraphic.addXYLoc(0, 8, tgBaseY + 24);
    tempGraphic.addXYLoc(0, 8, tgBaseY + 12);
    tempGraphic.addXYLoc(0, 20, tgBaseY + 12);
    tempGraphic.addXYLoc(0, 32, tgBaseY + 12);
    tempGraphic.addXYLoc(0, 44, tgBaseY + 12);
    tempGraphic.addXYLoc(0, 56, tgBaseY + 12);
    tempGraphic.addXYLoc(0, 68, tgBaseY + 12);
    tempGraphic.addXYLoc(0, 80, tgBaseY + 12);
    tempGraphic.addXYLoc(0, 80, tgBaseY);
    tempGraphic.addXYLoc(0, 68, tgBaseY);
    tempGraphic.addXYLoc(0, 56, tgBaseY);
    tempGraphic.addXYLoc(0, 44, tgBaseY);
    tempGraphic.addXYLoc(0, 32, tgBaseY);
    tempGraphic.addXYLoc(0, 20, tgBaseY);
    tempGraphic.addXYLoc(0, 8, tgBaseY);

    pathE1Q0B.assignNextComponent(queue0);

    pathE1Q0A.assignNextComponent(pathE1Q0B);

    var pathQ0Q1 = new PathComponent();
    tempGraphic = new DisplayElement(pathQ0Q1);

    queue0.assignNextComponent(pathQ0Q1);

    var pathQ0Q2 = new PathComponent();
    tempGraphic = new DisplayElement(pathQ0Q2);

    queue0.assignNextComponent(pathQ0Q2);

    var pathQ0Q3 = new PathComponent();
    tempGraphic = new DisplayElement(pathQ0Q3);

    queue0.assignNextComponent(pathQ0Q3);

    var routingTableQ123 = [[1.0],[1.0],[1.0]];  //not actually needed since routingMethod is 1 here
    var queue1 = new QueueComponent(3.0, 3, routingTableQ123);
    queue1.setRoutingMethod(1);  //1 single connection, 2 distribution logic, 3 model logic
    queue1.setComponentName("Q1");
    queue1.setComponentGroup("Primary");

    tempGraphic = new DisplayElement(queue1, 141, 131, 64, 36);
    tgBaseY = 29;  //53
    tempGraphic.addXYLoc(0, 32, tgBaseY);
    tempGraphic.addXYLoc(0, 20, tgBaseY);
    tempGraphic.addXYLoc(0, 8, tgBaseY);

    pathQ0Q1.assignNextComponent(queue1);

    var queue2 = new QueueComponent(3.0, 3, routingTableQ123);
    queue2.setRoutingMethod(1);  //1 single connection, 2 distribution logic, 3 model logic
    queue2.setComponentName("Q2");
    queue2.setComponentGroup("Primary");

    tempGraphic = new DisplayElement(queue2, 212, 131, 64, 36);
    tgBaseY = 29; //53;
    tempGraphic.addXYLoc(0, 32, tgBaseY);
    tempGraphic.addXYLoc(0, 20, tgBaseY);
    tempGraphic.addXYLoc(0, 8, tgBaseY);

    pathQ0Q2.assignNextComponent(queue2);

    var queue3 = new QueueComponent(3.0, 3, routingTableQ123);
    queue3.setRoutingMethod(1);  //1 single connection, 2 distribution logic, 3 model logic
    queue3.setComponentName("Q3");
    queue3.setComponentGroup("Primary");

    tempGraphic = new DisplayElement(queue3, 283, 131, 64, 36);
    tgBaseY = 29; //53;
    tempGraphic.addXYLoc(0, 32, tgBaseY);
    tempGraphic.addXYLoc(0, 20, tgBaseY);
    tempGraphic.addXYLoc(0, 8, tgBaseY);

    pathQ0Q3.assignNextComponent(queue3);

    var pathQ1P1 = new PathComponent();
    tempGraphic = new DisplayElement(pathQ1P1);

    queue1.assignNextComponent(pathQ1P1);

    var pathQ2P2 = new PathComponent();
    tempGraphic = new DisplayElement(pathQ2P2);

    queue2.assignNextComponent(pathQ2P2);

    var pathQ3P3 = new PathComponent();
    tempGraphic = new DisplayElement(pathQ3P3);

    queue3.assignNextComponent(pathQ3P3);

    var routingTableP123 = [[0.72, 0.8, 1.0],[0.65,0.8,1.0],[0.348,0.8,1.0]];  //citizen, LPR, visitor / parking_lot, exit, secondary
    var processTimeP123 = [10.0,20.8,13.0];  //fast, slow visitor, slow citizen or LPR
    var process1 = new ProcessComponent(processTimeP123, 0, 1, routingTableP123);
    process1.setRoutingMethod(3);  //1 single connection, 2 distribution logic, 3 model logic
    process1.setComponentName("P1");
    process1.setComponentGroup("Primary");

    tempGraphic = new DisplayElement(process1, 141, 192, 64, 36);
    tgBaseY = 29; //53;
    tempGraphic.addXYLoc(0, 32, tgBaseY);

    pathQ1P1.assignNextComponent(process1);

    var process2 = new ProcessComponent(processTimeP123, 0, 1, routingTableP123);
    process2.setRoutingMethod(3);  //1 single connection, 2 distribution logic, 3 model logic
    process2.setComponentName("P2");
    process2.setComponentGroup("Primary");

    tempGraphic = new DisplayElement(process2, 212, 192, 64, 36);
    tgBaseY = 29; //53;
    tempGraphic.addXYLoc(0, 32, tgBaseY);

    pathQ2P2.assignNextComponent(process2);

    var process3 = new ProcessComponent(processTimeP123, 0, 1, routingTableP123);
    process3.setRoutingMethod(3);  //1 single connection, 2 distribution logic, 3 model logic
    process3.setComponentName("P3");
    process3.setComponentGroup("Primary");

    tempGraphic = new DisplayElement(process3, 283, 192, 64, 36);
    tgBaseY = 29; //53;
    tempGraphic.addXYLoc(0, 32, tgBaseY);

    pathQ3P3.assignNextComponent(process3);

    var pathP1X1 = new PathComponent(30.0);
    tempGraphic = new DisplayElement(pathP1X1);

    process1.assignNextComponent(pathP1X1);

    var pathP2X1 = new PathComponent(30.0);
    tempGraphic = new DisplayElement(pathP2X1);

    process2.assignNextComponent(pathP2X1);

    var pathP3X1 = new PathComponent(30.0);
    tempGraphic = new DisplayElement(pathP3X1);

    process3.assignNextComponent(pathP3X1);

    var exit1 = new ExitComponent();
    exit1.setComponentName("Exit1");

    tempGraphic = new DisplayElement(exit1, 210, 429, 68, 20);

    pathP1X1.assignNextComponent(exit1);
    pathP2X1.assignNextComponent(exit1);
    pathP3X1.assignNextComponent(exit1);

    var pathP1Q10 = new PathComponent();
    tempGraphic = new DisplayElement(pathP1Q10);

    process1.assignNextComponent(pathP1Q10);

    var pathP2Q10 = new PathComponent();
    tempGraphic = new DisplayElement(pathP2Q10);

    process2.assignNextComponent(pathP2Q10);

    var pathP3Q10 = new PathComponent();
    tempGraphic = new DisplayElement(pathP3Q10);

    process3.assignNextComponent(pathP3Q10);

    var routingTableQ10 = [[1.0],[1.0],[1.0]];  //not actually needed since routingMethod is 2 here
    var queue10 = new QueueComponent(3.0, Infinity, routingTableQ10);
    queue10.setRoutingMethod(2);  //1 single connection, 2 distribution logic, 3 model logic
    queue10.setComponentName("Q10");
    queue10.setComponentGroup("Secondary");

    tempGraphic = new DisplayElement(queue10, 314, 253, 64, 48);
    tgBaseY = 29;  //53
    tempGraphic.addXYLoc(0, 32, tgBaseY + 12);
    tempGraphic.addXYLoc(0, 20, tgBaseY + 12);
    tempGraphic.addXYLoc(0, 8, tgBaseY + 12);
    tempGraphic.addXYLoc(0, 8, tgBaseY);
    tempGraphic.addXYLoc(0, 20, tgBaseY);
    tempGraphic.addXYLoc(0, 32, tgBaseY);
    tempGraphic.addXYLoc(0, 44, tgBaseY);
    tempGraphic.addXYLoc(0, 56, tgBaseY);

    pathP1Q10.assignNextComponent(queue10);
    pathP2Q10.assignNextComponent(queue10);
    pathP3Q10.assignNextComponent(queue10);

    var pathQ10P10 = new PathComponent();
    tempGraphic = new DisplayElement(pathQ10P10);

    queue10.assignNextComponent(pathQ10P10);

    var pathQ10P11 = new PathComponent();
    tempGraphic = new DisplayElement(pathQ10P11);

    queue10.assignNextComponent(pathQ10P11);

    var routingTableP1011 = [[0.8,1.0],[0.8,1.0],[0.8, 1.0]];
    var processTimeP1011 = [40.0,40.0,40.0];  //fast, slow visitor, slow citizen or LPR
    var process10 = new ProcessComponent(processTimeP1011, 0, 1, routingTableP1011);
    process10.setRoutingMethod(3);  //1 single connection, 2 distribution logic, 3 model logic
    process10.setComponentName("P10");
    process10.setComponentGroup("Secondary");

    tempGraphic = new DisplayElement(process10, 279, 326, 64, 36);
    tgBaseY = 29; //53;
    tempGraphic.addXYLoc(0, 32, tgBaseY);

    pathQ10P10.assignNextComponent(process10);

    var pathP10X1 = new PathComponent();
    tempGraphic = new DisplayElement(pathP10X1);

    process10.assignNextComponent(pathP10X1);

    pathP10X1.assignNextComponent(exit1);

    var process11 = new ProcessComponent(processTimeP1011, 0, 1, routingTableP1011);
    process11.setRoutingMethod(3);  //1 single connection, 2 distribution logic, 3 model logic
    process11.setComponentName("P11");
    process11.setComponentGroup("Secondary");

    tempGraphic = new DisplayElement(process11, 350, 326, 64, 36);
    tgBaseY = 29; //53;
    tempGraphic.addXYLoc(0, 32, tgBaseY);

    pathQ10P11.assignNextComponent(process11);

    var pathP11X1 = new PathComponent();
    tempGraphic = new DisplayElement(pathP11X1);

    process11.assignNextComponent(pathP11X1);

    pathP11X1.assignNextComponent(exit1);

    var pathP10X2 = new PathComponent();
    tempGraphic = new DisplayElement(pathP10X2);

    process10.assignNextComponent(pathP10X2);

    var pathP11X2 = new PathComponent();
    tempGraphic = new DisplayElement(pathP11X2);

    process11.assignNextComponent(pathP11X2);

    var exit2 = new ExitComponent();
    exit2.setComponentName("Exit2");
    tempGraphic = new DisplayElement(exit2, 314, 400, 68, 20);

    pathP10X2.assignNextComponent(exit2);
    pathP11X2.assignNextComponent(exit2);

    var globalProcessTimeSettings = [[5,7,9],[30,50,80]];
    function processTimeBag1(entity) {
      var processTime;
      var globalIndex = 1;
      if (entity.getPropertyValue("Residency") == "Citizen") {
        processTime = globalProcessTimeSettings[globalIndex][0];
      } else if (entity.getPropertyValue("Residency") == "LPR") {
        processTime = globalProcessTimeSettings[globalIndex][1];
      } else if (entity.getPropertyValue("Residency") == "Visitor") {
        processTime = globalProcessTimeSettings[globalIndex][2];
      }
      return processTime;
    }
    
/*    function processTimeBag1(entity) {
      var processTime;
      if (entity.getPropertyValue("Residency") == "Citizen") {
        processTime = 30;
      } else if (entity.getPropertyValue("Residency") == "LPR") {
        processTime = 50;
      } else if (entity.getPropertyValue("Residency") == "Visitor") {
        processTime = 80;
      }
      return processTime;
    } */
    var routingTableB1 = [[1.0],[1.0],[1.0]];
    //var processTimeB1 = [30.0,50.0,80.0];  //citizen, LPR, or visitor
    //var bag1 = new BagComponent(processTimeB1, 1, 12, routingTableB1);
    var bag1 = new BagComponent(processTimeBag1, 12, 12, 3, routingTableB1, true, 10.0, 10.0);
    bag1.setRoutingMethod(1);  //1 single connection, 2 distribution logic, 3 model logic
    bag1.setComponentName("B1");
    bag1.setComponentGroup("Parking Lot");
    
    tempGraphic = new DisplayElement(bag1, 130, 253, 52, 90);
    tgBaseY = 29;
    tempGraphic.addXYLoc(0, 8, tgBaseY);
    tempGraphic.addXYLoc(0, 20, tgBaseY);
    tempGraphic.addXYLoc(0, 32, tgBaseY);
    tempGraphic.addXYLoc(0, 44, tgBaseY);
    tempGraphic.addXYLoc(0, 8, tgBaseY + 12);
    tempGraphic.addXYLoc(0, 20, tgBaseY + 12);
    tempGraphic.addXYLoc(0, 32, tgBaseY + 12);
    tempGraphic.addXYLoc(0, 44, tgBaseY + 12);
    tempGraphic.addXYLoc(0, 8, tgBaseY + 24);
    tempGraphic.addXYLoc(0, 20, tgBaseY + 24);
    tempGraphic.addXYLoc(0, 32, tgBaseY + 24);
    tempGraphic.addXYLoc(0, 44, tgBaseY + 24);  //end fixed spaces = maxCapacity
    tempGraphic.addXYLoc(0, 26, tgBaseY + 52);  //start spaces for exitQueue
    tempGraphic.addXYLoc(0, 14, tgBaseY + 52);
    tempGraphic.addXYLoc(0, 14, tgBaseY + 40);
    tempGraphic.addXYLoc(0, 26, tgBaseY + 40);
    tempGraphic.addXYLoc(0, 38, tgBaseY + 40);
    
    var pathP1B1 = new PathComponent();
    tempGraphic = new DisplayElement(pathP1B1);
    
    process1.assignNextComponent(pathP1B1);
    
    pathP1B1.assignNextComponent(bag1);
    
    var pathP2B1 = new PathComponent();
    tempGraphic = new DisplayElement(pathP2B1);
    
    process2.assignNextComponent(pathP2B1);
    
    pathP2B1.assignNextComponent(bag1);
    
    var pathP3B1 = new PathComponent();
    tempGraphic = new DisplayElement(pathP3B1);
    
    process3.assignNextComponent(pathP3B1);
    
    pathP3B1.assignNextComponent(bag1);
    
/*    var pathB1X1 = new PathComponent();
    tempGraphic = new DisplayElement(pathB1X1);
    
    bag1.assignNextComponent(pathB1X1);
    
    pathB1X1.assignNextComponent(exit1);  */

    var routingTableP15 = [[1.0],[1.0],[1.0]];
    var processTimeP15 = [30.0,30.0,30.0];  //fast, slow visitor, slow citizen or LPR
    var process15 = new ProcessComponent(processTimeP15, 1, 1, routingTableP15);
    process15.setRoutingMethod(1);  //1 single connection, 2 distribution logic, 3 model logic
    process15.setComponentName("P15");
    process15.setComponentGroup("Parking Lot");
    
    tempGraphic = new DisplayElement(process15, 157, 368, 64, 36);
    tgBaseY = 29;
    tempGraphic.addXYLoc(0, 32, tgBaseY);
    
    var pathB1P15 = new PathComponent();
    tempGraphic = new DisplayElement(pathB1P15);
    
    bag1.assignNextComponent(pathB1P15);
    
    pathB1P15.assignNextComponent(process15);
    
    var pathP15X1 = new PathComponent();
    tempGraphic = new DisplayElement(pathP15X1);
    
    process15.assignNextComponent(pathP15X1);
    
    pathP15X1.assignNextComponent(exit1);

    var startSubJourneyBag1 = new StartSubJourneyComponent(bag1);
    bag1.assignStartSubJourneyComponent(startSubJourneyBag1);
    tempGraphic = new DisplayElement(startSubJourneyBag1, 0, 0, 128, 263);

    var returnFromSubJourneyBag1 = new ReturnFromSubJourneyComponent(bag1);
    bag1.assignReturnFromSubJourneyComponent(returnFromSubJourneyBag1);
    tempGraphic = new DisplayElement(returnFromSubJourneyBag1, 128, 333, 0, 0);
    
    var pathB1Q20A = new PathComponent();
    tempGraphic = new DisplayElement(pathB1Q20A, 0, 0, 95, 80);
    
    var pathB1Q20B = new PathComponent();
    tempGraphic = new DisplayElement(pathB1Q20B, 95, 80, 0, 0);
    
    var routingTableQ20 = [[1.0],[1.0],[1.0]];  //not actually needed since routingMethod is 2 here
    var queue20 = new QueueComponent(3.0, Infinity, routingTableQ20);
    queue20.setRoutingMethod(1);  //1 single connection, 2 distribution logic, 3 model logic
    queue20.setComponentName("Q20");
    queue20.setComponentGroup("Ped Primary");

    tempGraphic = new DisplayElement(queue20, 30, 100, 64, 48);
    tgBaseY = 29;  //53
    tempGraphic.addXYLoc(0, 32, tgBaseY + 12);
    tempGraphic.addXYLoc(0, 20, tgBaseY + 12);
    tempGraphic.addXYLoc(0, 8, tgBaseY + 12);
    tempGraphic.addXYLoc(0, 8, tgBaseY);
    tempGraphic.addXYLoc(0, 20, tgBaseY);
    tempGraphic.addXYLoc(0, 32, tgBaseY);
    tempGraphic.addXYLoc(0, 44, tgBaseY);
    tempGraphic.addXYLoc(0, 56, tgBaseY);

    startSubJourneyBag1.assignNextComponent(pathB1Q20A);
    
    pathB1Q20A.assignNextComponent(pathB1Q20B);
    
    pathB1Q20B.assignNextComponent(queue20);

    var routingTableP20 = [[0.5,1.0],[0.5,1.0],[0.5,1.0]];
    var processTimeP20 = [10.0,10.0,10.0];  //fast, slow visitor, slow citizen or LPR
    var process20 = new ProcessComponent(processTimeP20, 1, 1, routingTableP20);
    process20.setRoutingMethod(3);  //1 single connection, 2 distribution logic, 3 model logic
    process20.setComponentName("P20");
    process20.setComponentGroup("Ped Primary");
    
    tempGraphic = new DisplayElement(process20, 30, 173, 64, 36);
    tgBaseY = 29;
    tempGraphic.addXYLoc(0, 32, tgBaseY);
    
    var pathQ20P20 = new PathComponent();
    tempGraphic = new DisplayElement(pathQ20P20);

    queue20.assignNextComponent(pathQ20P20);
    
    pathQ20P20.assignNextComponent(process20);
    
    var pathP20B1 = new PathComponent();
    tempGraphic = new DisplayElement(pathP20B1);

    process20.assignNextComponent(pathP20B1);

    pathP20B1.assignNextComponent(returnFromSubJourneyBag1);    
/*
    var routingTableQ21 = [[1.0],[1.0],[1.0]];  //not actually needed since routingMethod is 2 here
    var queue21 = new QueueComponent(3.0, Infinity, routingTableQ21);
    queue21.setRoutingMethod(1);  //1 single connection, 2 distribution logic, 3 model logic
    queue21.setComponentName("Q21");
    queue21.setComponentGroup("Ped Secondary");

    tempGraphic = new DisplayElement(queue21, 5, 284, 64, 48);
    tgBaseY = 29;  //53
    tempGraphic.addXYLoc(0, 32, tgBaseY + 12);
    tempGraphic.addXYLoc(0, 20, tgBaseY + 12);
    tempGraphic.addXYLoc(0, 8, tgBaseY + 12);
    tempGraphic.addXYLoc(0, 8, tgBaseY);
    tempGraphic.addXYLoc(0, 20, tgBaseY);
    tempGraphic.addXYLoc(0, 32, tgBaseY);
    tempGraphic.addXYLoc(0, 44, tgBaseY);
    tempGraphic.addXYLoc(0, 56, tgBaseY);

    var pathP20Q21 = new PathComponent();
    tempGraphic = new DisplayElement(pathP20Q21);

    process20.assignNextComponent(pathP20Q21);
    
    pathP20Q21.assignNextComponent(queue21);

    var routingTableP21 = [[1.0],[1.0],[1.0]];
    var processTimeP21 = [40.0,40.0,40.0];  //fast, slow visitor, slow citizen or LPR
    var process21 = new ProcessComponent(processTimeP21, 1, 1, routingTableP21);
    process21.setRoutingMethod(3);  //1 single connection, 2 distribution logic, 3 model logic
    process21.setComponentName("P21");
    process21.setComponentGroup("Ped Secondary");
    
    tempGraphic = new DisplayElement(process21, 5, 357, 64, 36);
    tgBaseY = 29;
    tempGraphic.addXYLoc(0, 32, tgBaseY);
    
    var pathQ21P21 = new PathComponent();
    tempGraphic = new DisplayElement(pathQ21P21);

    queue21.assignNextComponent(pathQ21P21);
    
    pathQ21P21.assignNextComponent(process21);

    var pathP21B1A = new PathComponent();
    tempGraphic = new DisplayElement(pathP21B1A, 0, 0, 95, 413);

    var pathP21B1B = new PathComponent();
    tempGraphic = new DisplayElement(pathP21B1B, 95, 413, 0, 0);

    process21.assignNextComponent(pathP21B1A);
    
    pathP21B1A.assignNextComponent(pathP21B1B);
    
    pathP21B1B.assignNextComponent(returnFromSubJourneyBag1);
  */
  
    var routingTableC21 = [[1.0],[1.0],[1.0]];  //not actually needed since routingMethod is 1 here
    var processTimeC21 = [40.0,40.0,40.0];
    var combined21 = new CombinedComponent(3.0, processTimeC21, 1, 2, 1, routingTableC21);
    combined21.setRoutingMethod(1);  //1 single connection, 2 distribution logic, 3 model logic
    combined21.setComponentName("C21");
    combined21.setComponentGroup("Ped Secondary");

    tempGraphic = new DisplayElement(combined21, 5, 234, 64, 60);
    tgBaseY = 29;  //53
    tempGraphic.addXYLoc(0, 32, tgBaseY + 12);
    tempGraphic.addXYLoc(0, 20, tgBaseY + 12);
    tempGraphic.addXYLoc(0, 8, tgBaseY + 12);
    tempGraphic.addXYLoc(0, 8, tgBaseY);
    tempGraphic.addXYLoc(0, 20, tgBaseY);
    tempGraphic.addXYLoc(0, 32, tgBaseY);
    tempGraphic.addXYLoc(0, 44, tgBaseY);
    tempGraphic.addXYLoc(0, 56, tgBaseY);
    
    tempGraphic.addXYLoc(0, 32, tgBaseY+24);
  
    var pathP20C21 = new PathComponent();
    tempGraphic = new DisplayElement(pathP20C21);

    process20.assignNextComponent(pathP20C21);
    
    pathP20C21.assignNextComponent(combined21);

    var pathC21B1 = new PathComponent();
    tempGraphic = new DisplayElement(pathC21B1);

    combined21.assignNextComponent(pathC21B1);

    pathC21B1.assignNextComponent(returnFromSubJourneyBag1);

//********************************
    addToGroupStatsNameListWrapper("System");

    function initGraphics3DEntities() {
      for (var i = 0; i < global3DMaxEntityCount; i++) {
        define3DEntity(10000, 10000, 5, global3DEntityHeight, 8, globalReadyColor, globalReadyVertexColor);
      }
      normalize3DEntities(0);  //parameter is starting index
    }

    dummy2 = 0;
    /**/
//////////////////////////////////
    /*    var queue1 = new QueueComponent();
     var queue1DataGroup = new DisplayGroup("Queue",175,79,80,"#00FFFF","#FF0000","#FFFF00",0.0);
     var gtemp = queue1.getComponentID();
     queue1DataGroup.addValue(gtemp,"Comp. ID","integer");
     gtemp = queue1.getCountInQueue();
     queue1DataGroup.addValue(gtemp,"# In Queue","integer");
     function queue1DataGroupUpdate() {
     var temp = queue1.getComponentID();
     queue1DataGroup.valueList[0].updateValue(temp);
     temp = queue1.getCountInQueue();
     queue1DataGroup.valueList[1].updateValue(temp);
     };

     var queue1DataGroupEntry = new DisplayGroup("",175,118,80,"#00FFFF","#FF0000","#FFFF00",2.0);
     queue1DataGroupEntry.setVisibility(false);
     gtemp = queue1.getEntryEntityID();
     queue1DataGroupEntry.addValue(gtemp,"Entry ID","integer");
     gtemp = queue1.getEntryTime();
     queue1DataGroupEntry.addValue(gtemp,"Entry Time","numdec",5);
     function queue1DataGroupEntryUpdate() {
     var temp = queue1.getEntryEntityID();
     var updated0 = queue1DataGroupEntry.valueList[0].updateValue(temp);
     var temp = queue1.getEntryTime();
     var updated1 = queue1DataGroupEntry.valueList[1].updateValue(temp);
     if (updated0 || updated1) {
     queue1DataGroupEntry.turnOn();
     }
     }
     //queue1.defineDataGroup(175,79,80,"#00FFFF","#FF0000","#FFFF00");

     entry1.assignNextComponent(queue1);

     var process1 = new ProcessComponent(2.0,9.0);
     //process1.defineDataGroup(10,127,80,"#00FFFF","#FF0000","#FFFF00");
     process1.assignPreviousComponent(queue1);

     queue1.assignNextComponent(process1);
     */
//////////////////////////////////
    //arrival1.basicDefine(20,20,"#00FFFF","#8888FF","#FF0000",globalCTX);

    //var entry1 = new entryComponent(30.0,arrivalSchedule);

    /*    var entityA = new entity1(11.0,10.0,100.0);
     var entityB = new entity1(13.0,13.0,100.0);
     var entityC = new entity2a(12.0,-40,5,-1);
     var entityD = new entity3(0.0,5);

     var entityE = new entity4(0.0,45.0,45.0,flag1);
     var entityF = new entity4(0.0,63.7,63.7,flag2);

     var entityG = new entity5(0.0,flag1);
     var entityH = new entity5(0.0,flag2);
     */
    //***** main event loop *************************************************************
//***************************************************************************************
//*** end Discrete-Event Simulation Framework
//***************************************************************************************

//***************************************************************************************
//*** begin animation section
//***************************************************************************************
    //handle to animation mechanism
    var requestID;
    //status flag
    //var running = false;

    var numComponents = setOfComponents.length;

    function verifyModel() {
      var modelOK = true;
      var verifyErrorCodes = "";
      var i;
      var error;

      //verify forward and backward links exist and are connected to legitimate elements
      for (i = 0; i < numComponents; i++) {
        error = setOfComponents[i].verifyLinks();
        if (error.length > 0) {
          verifyErrorCodes += error;
          modelOK = false;
        }
      }

      //ensure Path components have exclusive setting of their terminating (non-path) component
      for (i = 0; i < numComponents; i++) {  //TODO: ensure all paths are properly assigned, depends on order of declaration and connection, go backward from all non-path components
        if (setOfComponents[i].componentType == "Path") {
          setOfComponents[i].setExclusive(setOfComponents[i].getNextExclusive());
        }
      }

      //verify that forward links from EntryComponents are NOT exclusive
      for (i = 0; i < numComponents; i++) {
        if (setOfComponents[i].getComponentType() == "Entry") {
          //test to ensure all next components are NOT exclusive
          error = setOfComponents[i].verifyNextNotExclusive();
          if (error.length > 0) {
            verifyErrorCodes += error;
            modelOK = false;
          }
        }
      }
      //ensure components use downstream distribution method appropriate to the kinds of downstream connections (single, distribution, routing logic)

      //get destination component indices for outgoing links
      for (i = 0; i < numComponents; i++) {
        if ((setOfComponents[i].componentType == "Queue") ||
            (setOfComponents[i].componentType == "Process")) {
          setOfComponents[i].getNextComponentIDs();
        }
      }

      //set beginning and ending locations for path components
      for (i = 0; i < numComponents; i++) {
        if (setOfComponents[i].componentType == "Path") {
          var location;
          //get location of source node
          location = setOfComponents[i].previousComponent.graphic.getOutNode();
          setOfComponents[i].graphic.setStartPoint(location.x, location.y);
          //get location of destination node
          if (setOfComponents[i].nextComponent.getComponentType() != "Path") {
            location = setOfComponents[i].nextComponent.graphic.getInNode();
            setOfComponents[i].graphic.setEndPoint(location.x, location.y);
          } else {
            //assume starting location was set by hand, necessary for path-to-path connections
          }
        }
      }
      for (i = 0; i < numComponents; i++) {
        if (setOfComponents[i].componentType == "Path") {
          setOfComponents[i].calcPathLength();
        }
      }
      
      //define 3D display elements based on info in 2D DisplayElements
      for (i = 0; i < numComponents; i++) {
        if (setOfComponents[i].getComponentType() != "Arrivals") {
          setOfComponents[i].graphic.define3DComponent();
        }
      }

      if (!modelOK) {
        displayProgressText(verifyErrorCodes);
        displayProgressText("Model configuration errors identified");
      } else {
        displayProgressText("Model configuration verified");
      }
    }  //verify model

    //verifyModel();

    
//***************************************************************************************
//*** set up reference grid
//***************************************************************************************
    function define3DLine(x1,y1,x2,y2,lineColor) {
      var gridMaterial = new THREE.LineBasicMaterial({ color: lineColor });
      var geometry = new THREE.Geometry();
      geometry.vertices.push(
        new THREE.Vector3(x1, 0, y1),
        new THREE.Vector3(x2, 0, y2)
      );
      var line = new THREE.Line(geometry, gridMaterial);
      scene.add(line);
    }

    function defineReferenceGrid() {
      var smidge = 0.00000001;
      var xMin = global3DMinX;
      var xMax = global3DMaxX;
      var xInc = (xMax - xMin) / 26;
      xMin -= xInc;
      xMax += xInc;
      var xMiddle = (xMin + xMax) / 2.0;
      var zMin = global3DMinY;
      var zMax = global3DMaxY;
      var zInc = (zMax - zMin) / 36;
      zMin -= zInc;
      zMax += zInc;
      var zMiddle = (zMin + zMax) / 2.0;
      xMax += smidge;
      zMax += smidge;
      
      var gridLineColor;
      for (var z=zMin; z<=zMax; z+=zInc) {
        if ((z < zMiddle-smidge) || (z > zMiddle+smidge)) {
          gridLineColor = "#000088";
        } else {  //center line
          gridLineColor = "#880000";
        }
        define3DLine(xMin,z,xMax,z,gridLineColor);
      }
      for (var x=xMin; x<=xMax; x+=xInc) {
        if ((x < xMiddle-smidge) || (x > xMiddle+smidge)) {
          gridLineColor = "#000088";
        } else {
          gridLineColor = "#880000";
        }
        define3DLine(x,zMin,x,zMax,gridLineColor);
      }
    }  //defineReferenceGrid
//***************************************************************************************
//*** camera setup
//***************************************************************************************
    var cameraRadius;
    var cameraRevolutionAngle;
    var cameraRevolutionIncrement;
    var global3DBaseX;
    var global3DBaseY;
    var global3DBaseZ;
    var global3DLookTarget;
    
    function initGraphics3DCamera() {
      //this must all be set up AFTER the components have been initialized
      //var cameraRadius = 480.0;
      cameraRadius = 300.0;
      cameraRevolutionAngle = Math.PI * 0.5;
      cameraRevolutionIncrement = -0.005;

      var xWid = global3DMaxX - global3DMinX;
      var yWid = global3DMaxY - global3DMinY;

      if (xWid > yWid) {
        cameraRadius = xWid * global3DCameraRadiusFactor;
      } else {
        cameraRadius = yWid * global3DCameraRadiusFactor;
      }

      //scene.position.x = (global3DMinX + global3DMaxX) / 2;
      //scene.position.y = 0;
      //scene.position.z = (global3DMinY + global3DMaxY) / 2;

      global3DBaseX = (global3DMinX + global3DMaxX) / 2;
      global3DBaseY = 0;
      global3DBaseZ = (global3DMinY + global3DMaxY) / 2;

      //camera.position.x = scene.position.x + cameraRadius * Math.cos(cameraRevolutionAngle);
      //camera.position.z = scene.position.z + cameraRadius * Math.sin(cameraRevolutionAngle);
      camera.position.x = global3DBaseX + cameraRadius * Math.cos(cameraRevolutionAngle);
      camera.position.y = global3DCameraHeight; //48;
      camera.position.z = global3DBaseZ + cameraRadius * Math.sin(cameraRevolutionAngle);

      global3DLookTarget = new THREE.Vector3(global3DBaseX, global3DBaseY, global3DBaseZ);
      camera.lookAt(global3DLookTarget);

      defineReferenceGrid();

      if (fullScreen3D) {
        if (stereoVR) {
          effect.render(scene, camera);
        } else {
          renderer.render(scene, camera);
        }
      } else {
        renderer.render(scene, camera);
      }

    }  //initGraphics3DCamera
    
    function drawModel() {
      clearCanvas("#000000");
      var i;
      /*      for (i=0; i<numComponents; i++) {
       setOfComponents[i].drawData();
       }
       for (i=0; i<numComponents; i++) {
       if (setOfComponents[i].componentType == "Path") {
       setOfComponents[i].drawNodes();
       }
       }
       for (i=0; i<numComponents; i++) {
       if (setOfComponents[i].componentType == "Path") {
       setOfComponents[i].drawEntities();
       }
       }  */
      for (i = 0; i < numComponents; i++) {
        if (setOfComponents[i].getComponentType() == "Path") {
          setOfComponents[i].updateGraphic();
          setOfComponents[i].graphic.drawBasic();
          //setOfComponents[i].drawData();
        } else if (setOfComponents[i].getComponentType() != "Arrivals") {
          setOfComponents[i].updateGraphic();
          setOfComponents[i].graphic.drawBasic();
        } else if (setOfComponents[i].getComponentType() == "Arrivals") {
          //setOfComponents[i].drawData();
        }
      }
      for (i = 0; i < numComponents; i++) {
        if (setOfComponents[i].getComponentType() == "Path") {
          setOfComponents[i].graphic.drawNodes();
          //setOfComponents[i].drawNodes();
        } else if (setOfComponents[i].getComponentType() != "Arrivals") {
          setOfComponents[i].graphic.drawNodes();
        }
      }
      for (i = 0; i < numComponents; i++) {
        if (setOfComponents[i].componentType == "Path") {
          setOfComponents[i].graphic.drawEntities();
          //setOfComponents[i].drawEntities();
        } else if (setOfComponents[i].componentType != "Arrivals") {
          setOfComponents[i].graphic.drawEntities();
        }
      }
    }  //drawModel

    //drawModel();

    function update3D() {
      //clearCanvas3D("#0000FF");
      var i;
      global3DRefreshEntityCount = 0;
      //change color of path- or box-components if applicable
      //then update entities associated with each component
      for (i = 0; i < numComponents; i++) {
        if (setOfComponents[i].getComponentType() != "Arrivals") {
          setOfComponents[i].graphic.update3DComponent();
          setOfComponents[i].graphic.update3DEntities();
        }
      }
      normalize3DEntities(global3DRefreshEntityCount);
    }  //update3D

    //update3D();
    //if (fullScreen3D) {
    //  if (stereoVR) {
    //    effect.render(scene, camera);
    //  } else {
    //    renderer.render(scene, camera);
    //  }
    //} else {
    //  renderer.render(scene, camera);
    //}

    function updateAllDisplays() {
      drawModel();
      update3D();

      setOfComponents
      
      cameraRevolutionAngle += cameraRevolutionIncrement;
      if (cameraRevolutionAngle > Math.PI * 2.0) {
        cameraRevolutionAngle -= Math.PI * 2.0;
      } else if (cameraRevolutionAngle < 0) {
        cameraRevolutionAngle += Math.PI * 2.0;
      }
      camera.position.x = global3DBaseX + cameraRadius * Math.cos(cameraRevolutionAngle);
      camera.position.y = global3DCameraHeight; //48;
      camera.position.z = global3DBaseZ + cameraRadius * Math.sin(cameraRevolutionAngle);
      camera.lookAt(global3DLookTarget);

      if (fullScreen3D) {
        if (stereoVR) {
          effect.render(scene, camera);
        } else {
          renderer.render(scene, camera);
        }
      } else {
        renderer.render(scene, camera);
      }
    }  //updateAllDisplays

    function stepClick() {
      //do an iteration of the main event loop from the DES section
      if (keepRunning) {
        var stop = false;
        do {
          ceq.processCeq();

          var itemList = feq.getFirstItem();

          if (itemList) {
            feqCurrent = itemList[0];
            feqCurrent.entity.activate(feqCurrent.getNextState(), feqCurrent.entity2);
          } else {
            keepRunning = false;
          }

          if ((displayControlMode != "Time") || (displayControlUpdate)) {
            updateAllDisplays();
            updateSimClock(globalSimClock);
            stop = true;
          }
          displayControlUpdate = false;

          if (!keepRunning) {
            displayEndMessage();
            running = false;
            stop = true;
          }
        } while (!stop);
      }

    }  //stepClick

    function runClick() {
      running = true;
      requestID = window.requestAnimationFrame(animateSim);
    }

    function initGraphics() {
      var runButton = document.getElementById("run_button");
      var pseButton = document.getElementById("pause_button");
      var stpButton = document.getElementById("step_button");
      var rstButton = document.getElementById("reset_button");
      var tmoButton = document.getElementById("timeOps_button");
      var mltButton = document.getElementById("multiplier_button");
      runButton.disabled = false;
      pseButton.disabled = false;
      stpButton.disabled = false;
      rstButton.disabled = false;
      tmoButton.disabled = false;
      mltButton.disabled = false;
    
      initGraphics3D();          //set up the renderer
      verifyModel();             //define the environment elements
      initGraphics3DCamera();    //set up the camera
      initGraphics3DEntities();  //define the entities
      updateAllDisplays();       //update and draw
      if (fullScreen3D) {
        runClick();  //could do this at end of initGraphics instead, which would wait for the body onload tag initialization
      }
    }
    
    //initGraphics();

    function pauseClick() {
      running = false;
    }

    function resetClick() {
      //reset discrete-event mechanisms
      //globalComponentIDCounter = 0;  //don't reset this but remember it exists
      globalEntityIDCounter = 0;
      displayControlUpdate = true;
      updateSimClock(0.0);  //resets global simulation clock
      displayControlUpdate = false;
      clearProgressText();
      ceq = new CurrentEventsQueue();
      feq = new FutureEventsQueue();
      //reset other globals
      setOfEntities = [];
      keepRunning = true;
      finalStatsFlag = false;
      running = false;
      //reset components
      for (var i = 0; i < numComponents; i++) {
        setOfComponents[i].reset();
      }
      displayControl.reset();
      statsTimer.reset();

      //cameraRevolutionAngle = Math.PI * 0.5 - cameraRevolutionIncrement;
      updateAllDisplays();
    }

    //running = true;
    var notRunningCounter = 0;

    function animateSim() {
      if (running) {
        stepClick();
        requestID = window.requestAnimationFrame(animateSim);
      } else if (fullScreen3D) {
        notRunningCounter++;
        if (notRunningCounter >= 30) {
          notRunningCounter = 0;
          resetClick();
          running = true;
          //runClick();
        }
        requestID = window.requestAnimationFrame(animateSim);
      }
    }
    
//***************************************************************************************
//*** define 2D pan and zoom events
//***************************************************************************************
    var xPanMin = -200;  //globalBaseX
    var xPanMax = 200;
    var xPanInc = 2;
    var yPanMin = -200;  //globalBaseY
    var yPanMax = 200;
    var yPanInc = 2;
    
    function panDown(increment) {
      if (typeof increment === "undefined") {increment = yPanInc;}
      globalBaseY += increment;
      if (globalBaseY > yPanMax) {
        globalBaseY = yPanMax;
      }
      if (!running) {
        drawModel();
      } 
    }

    function panUp(increment) {
      if (typeof increment === "undefined") {increment = yPanInc;}
      globalBaseY -= increment;
      if (globalBaseY < yPanMin) {
        globalBaseY = yPanMin;
      }
      if (!running) {
        drawModel();
      } 
    }

    function panRight(increment) {
      if (typeof increment === "undefined") {increment = xPanInc;}
      globalBaseX += increment;
      if (globalBaseX > xPanMax) {
        globalBaseX = xPanMax;
      }
      if (!running) {
        drawModel();
      } 
    }

    function panLeft(increment) {
      if (typeof increment === "undefined") {increment = xPanInc;}
      globalBaseX -= increment;
      if (globalBaseX < xPanMin) {
        globalBaseX = xPanMin;
      }
      if (!running) {
        drawModel();
      } 
    }
    
    function resetPan() {
      globalBaseX = 0;
      globalBaseY = 0;
      if (!running) {
        drawModel();
      }
    }

    document.onkeydown = checkKey;

    function checkKey(e) {
      e = e || window.event;
      if (e.keyCode == '37') { //left arrow
        panLeft();
      } else if (e.keyCode == '39') { //right arrow
        panRight();
      } else if (e.keyCode == '38') { //up arrow
        panUp();
      } else if (e.keyCode == '40') { //down arrow
        panDown();
      } else if (e.keyCode == '66') { //b key
      } else if (e.keyCode == '70') { //f key
      } else if (e.keyCode == '36') { //home key
        resetPan();
      }
      //eat the event
      if (e.stopPropagation) {
        e.stopPropagation();
      } else {
        e.cancelBubble = true;
      }
    }
    
    ///////////////////mouse drag events
    var dragFlag = false;
    var startDragX;
    var startDragY;
    var dragBaseX;
    var dragBaseY;
    var dragLastX;
    var dragLastY;
    
    //start drag
    canvas.addEventListener("mousedown", function(event) {
      startDrag(event);
    });
    
    function startDrag(e) {
      startDragX = globalBaseX;
      startDragY = globalBaseY;
      dragBaseX = e.clientX;
      dragBaseY = e.clientY;
      dragLastX = dragBaseX;
      dragLastY = dragBaseY;
      dragFlag = true;
    }

    //end drag
    canvas.addEventListener("mouseup", function(event) {
      endDrag(event);
    });
    
    function endDrag(e) {
      dragFlag = false;
    }
    
    //move while dragging
    canvas.addEventListener("mousemove", function(event) {
      doDrag(event);
    });
    
    function doDrag(e) {
      if (dragFlag) {
        var currentX = e.clientX;
        var currentY = e.clientY;
        var incrementX = currentX - dragLastX;
        if (incrementX > 0) {
          panLeft(incrementX)
        } else if (incrementX < 0) {
          panRight(-incrementX)
        }
        var incrementY = currentY - dragLastY;
        if (incrementY > 0) {
          panUp(incrementY);
        } else if (incrementY < 0) {
          panDown(-incrementY);
        }
        dragLastX = currentX;
        dragLastY = currentY;
        //eat the event
        if (e.stopPropagation) {
          e.stopPropagation();
        } else {
          e.cancelBubble = true;
        }
      }    
    }
    
    //mouse leaves canvas
    canvas.addEventListener("mouseleave", function(event) {
      leaveDrag(event);
    });
    
    function leaveDrag(e) {
      if (dragFlag) {
        globalBaseX = startDragX;
        globalBaseY = startDragY;
        if (!running) {
          drawModel();
        }
        dragFlag = false;
      }
    }
/**/
  </script>
</body>
</html>